/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = " \\brief BufferDescriptor is a struct which describes buffer elements in\n        interleaved data buffers. Almost all Osd Evaluator APIs take\n        BufferDescriptors along with device-specific buffer objects.\n\n        The offset of BufferDescriptor can also be used to express a\n        batching offset if the data buffer is combined across multiple\n        objects together.\n\n        * Note that each element has the same data type (float)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Osd_BufferDescriptor {
    #[doc = " offset to desired element data"]
    pub offset: ::std::os::raw::c_int,
    #[doc = " number or length of the data"]
    pub length: ::std::os::raw::c_int,
    #[doc = " stride to the next element"]
    pub stride: ::std::os::raw::c_int,
}
pub const OpenSubdiv_v3_6_1_Sdc_SchemeType_SCHEME_BILINEAR: OpenSubdiv_v3_6_1_Sdc_SchemeType = 0;
pub const OpenSubdiv_v3_6_1_Sdc_SchemeType_SCHEME_CATMARK: OpenSubdiv_v3_6_1_Sdc_SchemeType = 1;
pub const OpenSubdiv_v3_6_1_Sdc_SchemeType_SCHEME_LOOP: OpenSubdiv_v3_6_1_Sdc_SchemeType = 2;
#[doc = "\n  \\brief Enumerated type for all subdivision schemes supported by OpenSubdiv\n"]
pub type OpenSubdiv_v3_6_1_Sdc_SchemeType = ::std::os::raw::c_uint;
#[doc = "< Used by Catmark and Bilinear"]
pub const OpenSubdiv_v3_6_1_Sdc_Split_SPLIT_TO_QUADS: OpenSubdiv_v3_6_1_Sdc_Split = 0;
#[doc = "< Used by Loop"]
pub const OpenSubdiv_v3_6_1_Sdc_Split_SPLIT_TO_TRIS: OpenSubdiv_v3_6_1_Sdc_Split = 1;
#[doc = "< Not currently used (potential future extension)"]
pub const OpenSubdiv_v3_6_1_Sdc_Split_SPLIT_HYBRID: OpenSubdiv_v3_6_1_Sdc_Split = 2;
#[doc = "\n  \\brief Enumerated type for all face splitting schemes\n"]
pub type OpenSubdiv_v3_6_1_Sdc_Split = ::std::os::raw::c_uint;
#[doc = "\n  \\brief Traits associated with the types of all subdivision schemes -- parameterized by\n  the scheme type.  All traits are also defined in the scheme itself.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc16SchemeTypeTraits23GetTopologicalSplitTypeENS1_10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetTopologicalSplitType(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> OpenSubdiv_v3_6_1_Sdc_Split;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc16SchemeTypeTraits18GetRegularFaceSizeENS1_10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetRegularFaceSize(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc16SchemeTypeTraits23GetRegularVertexValenceENS1_10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetRegularVertexValence(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc16SchemeTypeTraits24GetLocalNeighborhoodSizeENS1_10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetLocalNeighborhoodSize(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc16SchemeTypeTraits7GetNameENS1_10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetName(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> *const ::std::os::raw::c_char;
}
impl OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits {
    #[inline]
    pub unsafe fn GetTopologicalSplitType(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> OpenSubdiv_v3_6_1_Sdc_Split {
        OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetTopologicalSplitType(schemeType)
    }
    #[inline]
    pub unsafe fn GetRegularFaceSize(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetRegularFaceSize(schemeType)
    }
    #[inline]
    pub unsafe fn GetRegularVertexValence(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetRegularVertexValence(schemeType)
    }
    #[inline]
    pub unsafe fn GetLocalNeighborhoodSize(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetLocalNeighborhoodSize(schemeType)
    }
    #[inline]
    pub unsafe fn GetName(
        schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> *const ::std::os::raw::c_char {
        OpenSubdiv_v3_6_1_Sdc_SchemeTypeTraits_GetName(schemeType)
    }
}
#[doc = "\n  \\brief All supported options applying to subdivision scheme.\n\n  The Options class contains all supported options that can be applied to a\n  subdivision scheme to affect the shape of the limit surface.  These differ from\n  approximations that may be applied at a higher level, i.e. options to limit the\n  level of feature adaptive subdivision, options to ignore fractional creasing,\n  or creasing entirely, etc. These options define the shape of a particular\n  limit surface, including the \"shape\" of primitive variable data associated with\n  it.\n\n  The intent is that these sets of options be defined at a high level and\n  propagated into the lowest-level computation in support of each subdivision\n  scheme.  Ideally it remains a set of bit-fields (essentially an int) and so\n  remains light weight and easily passed around by value.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Sdc_Options {
    pub _vtxBoundInterp: OpenSubdiv_v3_6_1_Sdc_Options_EnumIntType,
    pub _fvarLinInterp: OpenSubdiv_v3_6_1_Sdc_Options_EnumIntType,
    pub _creasingMethod: OpenSubdiv_v3_6_1_Sdc_Options_EnumIntType,
    pub _triangleSub: OpenSubdiv_v3_6_1_Sdc_Options_EnumIntType,
}
#[doc = "< no boundary interpolation, except where\n< boundary edges were explicitly sharpened"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation_VTX_BOUNDARY_NONE:
    OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation = 0;
#[doc = "< all boundary edges sharpened and interpolated"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation_VTX_BOUNDARY_EDGE_ONLY:
    OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation = 1;
#[doc = "< all boundary edges and corner vertices\n< sharpened and interpolated"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation_VTX_BOUNDARY_EDGE_AND_CORNER:
    OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation = 2;
pub type OpenSubdiv_v3_6_1_Sdc_Options_VtxBoundaryInterpolation = ::std::os::raw::c_uint;
#[doc = "< smooth everywhere (\"edge only\")"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_NONE:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 0;
#[doc = "< sharpen corners only"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_CORNERS_ONLY:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 1;
#[doc = "< (\"edge corner\")"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_CORNERS_PLUS1:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 2;
#[doc = "< (\"edge and corner + propagate corner\")"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_CORNERS_PLUS2:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 3;
#[doc = "< sharpen all boundaries (\"always sharp\")"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_BOUNDARIES:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 4;
#[doc = "< bilinear interpolation (\"bilinear\")"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation_FVAR_LINEAR_ALL:
    OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = 5;
pub type OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation = ::std::os::raw::c_uint;
#[doc = "< Catmark rule"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_CreasingMethod_CREASE_UNIFORM:
    OpenSubdiv_v3_6_1_Sdc_Options_CreasingMethod = 0;
#[doc = "< Chaikin rule"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_CreasingMethod_CREASE_CHAIKIN:
    OpenSubdiv_v3_6_1_Sdc_Options_CreasingMethod = 1;
pub type OpenSubdiv_v3_6_1_Sdc_Options_CreasingMethod = ::std::os::raw::c_uint;
#[doc = "< Catmark weights (Catmark scheme only)"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_TriangleSubdivision_TRI_SUB_CATMARK:
    OpenSubdiv_v3_6_1_Sdc_Options_TriangleSubdivision = 0;
#[doc = "< \"smooth triangle\" weights (Catmark scheme only)"]
pub const OpenSubdiv_v3_6_1_Sdc_Options_TriangleSubdivision_TRI_SUB_SMOOTH:
    OpenSubdiv_v3_6_1_Sdc_Options_TriangleSubdivision = 1;
pub type OpenSubdiv_v3_6_1_Sdc_Options_TriangleSubdivision = ::std::os::raw::c_uint;
pub type OpenSubdiv_v3_6_1_Sdc_Options_EnumIntType = ::std::os::raw::c_uchar;
#[doc = "\n  \\brief Types, constants and utilities related to semi-sharp creasing -- whose implementation\n  is independent of the subdivision scheme.\n\n  Crease is intended to be a light-weight, trivially constructed class that computes\n  crease-related properties -- typically sharpness values and associated interpolation\n  weights.  An instance of Crease is defined with a set of options that include current\n  and future variations that will impact computations involving sharpness values.\n\n  The Crease methods do not use topological neighborhoods as input.  The methods here\n  rely more on the sharpness values and less on the topology, so we choose to work directly\n  with the sharpness values.  We also follow the trend of using primitive arrays in the\n  interface to encourage local gathering for re-use.\n\n  Note on the need for and use of sharpness values:\n      In general, mask queries rely on the sharpness values.  The common case of a smooth\n  vertex, when known, avoids the need to inspect them, but unless the rules are well understood,\n  users will be expected to provided them -- particularly when they expect the mask queries\n  to do all of the work (just determining if a vertex is smooth will require inspection of\n  incident edge sharpness).\n      Mask queries will occasionally require the subdivided sharpness values around the\n  child vertex.  So users will be expected to either provide them up front when known, or to be\n  gathered on demand.  Any implementation of subdivision with creasing cannot avoid subdividing\n  the sharpness values first, so keeping them available for re-use is a worthwhile consideration.\n"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Sdc_Crease {
    pub _options: OpenSubdiv_v3_6_1_Sdc_Options,
}
pub const OpenSubdiv_v3_6_1_Sdc_Crease_Rule_RULE_UNKNOWN: OpenSubdiv_v3_6_1_Sdc_Crease_Rule = 0;
pub const OpenSubdiv_v3_6_1_Sdc_Crease_Rule_RULE_SMOOTH: OpenSubdiv_v3_6_1_Sdc_Crease_Rule = 1;
pub const OpenSubdiv_v3_6_1_Sdc_Crease_Rule_RULE_DART: OpenSubdiv_v3_6_1_Sdc_Crease_Rule = 2;
pub const OpenSubdiv_v3_6_1_Sdc_Crease_Rule_RULE_CREASE: OpenSubdiv_v3_6_1_Sdc_Crease_Rule = 4;
pub const OpenSubdiv_v3_6_1_Sdc_Crease_Rule_RULE_CORNER: OpenSubdiv_v3_6_1_Sdc_Crease_Rule = 8;
#[doc = "\n  Enum for the types of subdivision rules applied based on sharpness values (note these\n  correspond to Hbr's vertex \"mask\").  The values are assigned to bit positions as it is\n  useful to use bitwise operations to inspect collections of vertices (i.e. all of the\n  vertices incident a particular face).\n"]
pub type OpenSubdiv_v3_6_1_Sdc_Crease_Rule = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "  Constants and related queries of sharpness values:\n"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc6Crease16SHARPNESS_SMOOTHE"]
    pub static OpenSubdiv_v3_6_1_Sdc_Crease_SHARPNESS_SMOOTH: f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Sdc6Crease18SHARPNESS_INFINITEE"]
    pub static OpenSubdiv_v3_6_1_Sdc_Crease_SHARPNESS_INFINITE: f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Sdc6Crease30SubdivideEdgeSharpnessAtVertexEfiPKf"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Crease_SubdivideEdgeSharpnessAtVertex(
        this: *const OpenSubdiv_v3_6_1_Sdc_Crease,
        edgeSharpness: f32,
        incidentEdgeCountAtEndVertex: ::std::os::raw::c_int,
        edgeSharpnessAroundEndVertex: *const f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Sdc6Crease36SubdivideEdgeSharpnessesAroundVertexEiPKfPf"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Crease_SubdivideEdgeSharpnessesAroundVertex(
        this: *const OpenSubdiv_v3_6_1_Sdc_Crease,
        incidentEdgeCountAtVertex: ::std::os::raw::c_int,
        incidentEdgeSharpnessAroundVertex: *const f32,
        childEdgesSharpnessAroundVertex: *mut f32,
    );
}
extern "C" {
    #[doc = "  Rule determination:\n      Mask queries do not require the Rule to be known, it can be determined from\n  the information provided, but it is generally more efficient when the Rule is known\n  and provided.  In particular, the Smooth case dominates and is known to be applicable\n  based on the origin of the vertex without inspection of sharpness.\n"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Sdc6Crease25DetermineVertexVertexRuleEfiPKf"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Crease_DetermineVertexVertexRule(
        this: *const OpenSubdiv_v3_6_1_Sdc_Crease,
        vertexSharpness: f32,
        incidentEdgeCount: ::std::os::raw::c_int,
        incidentEdgeSharpness: *const f32,
    ) -> OpenSubdiv_v3_6_1_Sdc_Crease_Rule;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Sdc6Crease25DetermineVertexVertexRuleEfi"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Crease_DetermineVertexVertexRule1(
        this: *const OpenSubdiv_v3_6_1_Sdc_Crease,
        vertexSharpness: f32,
        sharpEdgeCount: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Crease_Rule;
}
extern "C" {
    #[doc = "  \\brief Transitional weighting:\n      When the rules applicable to a parent vertex and its child differ, one or more\n  sharpness values has \"decayed\" to zero.  Both rules are then applicable and blended\n  by a weight between 0 and 1 that reflects the transition.  Most often this will be\n  a single sharpness value that decays from within the interval [0,1] to zero -- and\n  the weight to apply is exactly that sharpness value -- but more than one may decay,\n  and values > 1 may also decay to 0 in a single step while others within [0,1] may\n  remain > 0.\n      So to properly determine a transitional weight, sharpness values for both the\n  parent and child must be inspected, combined and clamped accordingly.\n"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Sdc6Crease31ComputeFractionalWeightAtVertexEffiPKfS4_"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Crease_ComputeFractionalWeightAtVertex(
        this: *const OpenSubdiv_v3_6_1_Sdc_Crease,
        vertexSharpness: f32,
        childVertexSharpness: f32,
        incidentEdgeCount: ::std::os::raw::c_int,
        incidentEdgeSharpness: *const f32,
        childEdgesSharpness: *const f32,
    ) -> f32;
}
impl OpenSubdiv_v3_6_1_Sdc_Crease {
    #[inline]
    pub unsafe fn SubdivideEdgeSharpnessAtVertex(
        &self,
        edgeSharpness: f32,
        incidentEdgeCountAtEndVertex: ::std::os::raw::c_int,
        edgeSharpnessAroundEndVertex: *const f32,
    ) -> f32 {
        OpenSubdiv_v3_6_1_Sdc_Crease_SubdivideEdgeSharpnessAtVertex(
            self,
            edgeSharpness,
            incidentEdgeCountAtEndVertex,
            edgeSharpnessAroundEndVertex,
        )
    }
    #[inline]
    pub unsafe fn SubdivideEdgeSharpnessesAroundVertex(
        &self,
        incidentEdgeCountAtVertex: ::std::os::raw::c_int,
        incidentEdgeSharpnessAroundVertex: *const f32,
        childEdgesSharpnessAroundVertex: *mut f32,
    ) {
        OpenSubdiv_v3_6_1_Sdc_Crease_SubdivideEdgeSharpnessesAroundVertex(
            self,
            incidentEdgeCountAtVertex,
            incidentEdgeSharpnessAroundVertex,
            childEdgesSharpnessAroundVertex,
        )
    }
    #[inline]
    pub unsafe fn DetermineVertexVertexRule(
        &self,
        vertexSharpness: f32,
        incidentEdgeCount: ::std::os::raw::c_int,
        incidentEdgeSharpness: *const f32,
    ) -> OpenSubdiv_v3_6_1_Sdc_Crease_Rule {
        OpenSubdiv_v3_6_1_Sdc_Crease_DetermineVertexVertexRule(
            self,
            vertexSharpness,
            incidentEdgeCount,
            incidentEdgeSharpness,
        )
    }
    #[inline]
    pub unsafe fn DetermineVertexVertexRule1(
        &self,
        vertexSharpness: f32,
        sharpEdgeCount: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Crease_Rule {
        OpenSubdiv_v3_6_1_Sdc_Crease_DetermineVertexVertexRule1(
            self,
            vertexSharpness,
            sharpEdgeCount,
        )
    }
    #[inline]
    pub unsafe fn ComputeFractionalWeightAtVertex(
        &self,
        vertexSharpness: f32,
        childVertexSharpness: f32,
        incidentEdgeCount: ::std::os::raw::c_int,
        incidentEdgeSharpness: *const f32,
        childEdgesSharpness: *const f32,
    ) -> f32 {
        OpenSubdiv_v3_6_1_Sdc_Crease_ComputeFractionalWeightAtVertex(
            self,
            vertexSharpness,
            childVertexSharpness,
            incidentEdgeCount,
            incidentEdgeSharpness,
            childEdgesSharpness,
        )
    }
}
extern "C" {
    #[link_name = "\u{1}GetTopologicalSplitType"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Scheme_GetTopologicalSplitType() -> OpenSubdiv_v3_6_1_Sdc_Split;
}
extern "C" {
    #[link_name = "\u{1}GetRegularFaceSize"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Scheme_GetRegularFaceSize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}GetRegularVertexValence"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Scheme_GetRegularVertexValence() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}GetLocalNeighborhoodSize"]
    pub fn OpenSubdiv_v3_6_1_Sdc_Scheme_GetLocalNeighborhoodSize() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Sdc_Scheme_LocalMask<WEIGHT> {
    pub _vWeights: *mut OpenSubdiv_v3_6_1_Sdc_Scheme_LocalMask_Weight<WEIGHT>,
    pub _eWeights: *mut OpenSubdiv_v3_6_1_Sdc_Scheme_LocalMask_Weight<WEIGHT>,
    pub _fWeights: *mut OpenSubdiv_v3_6_1_Sdc_Scheme_LocalMask_Weight<WEIGHT>,
    pub _vCount: ::std::os::raw::c_int,
    pub _eCount: ::std::os::raw::c_int,
    pub _fCount: ::std::os::raw::c_int,
    pub _fWeightsForCenters: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<WEIGHT>>,
}
pub type OpenSubdiv_v3_6_1_Sdc_Scheme_LocalMask_Weight<WEIGHT> = WEIGHT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_ConstArray<TYPE> {
    pub _begin: *const OpenSubdiv_v3_6_1_Vtr_ConstArray_value_type<TYPE>,
    pub _size: OpenSubdiv_v3_6_1_Vtr_ConstArray_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TYPE>>,
}
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_value_type<TYPE> = TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_size_type = ::std::os::raw::c_int;
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_const_reference<TYPE> = *const TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_const_iterator<TYPE> = *const TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_reference<TYPE> = *mut TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_ConstArray_iterator<TYPE> = *mut TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_Array<TYPE> {
    pub _base: OpenSubdiv_v3_6_1_Vtr_ConstArray<TYPE>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TYPE>>,
}
pub type OpenSubdiv_v3_6_1_Vtr_Array_value_type<TYPE> = TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_Array_size_type = ::std::os::raw::c_int;
pub type OpenSubdiv_v3_6_1_Vtr_Array_const_reference<TYPE> = *const TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_Array_reference<TYPE> = *mut TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_Array_iterator<TYPE> = *mut TYPE;
pub type OpenSubdiv_v3_6_1_Vtr_Index = ::std::os::raw::c_int;
pub type OpenSubdiv_v3_6_1_Vtr_LocalIndex = ::std::os::raw::c_ushort;
pub type OpenSubdiv_v3_6_1_Vtr_IndexVector = [u64; 3usize];
pub type OpenSubdiv_v3_6_1_Vtr_IndexArray =
    OpenSubdiv_v3_6_1_Vtr_Array<OpenSubdiv_v3_6_1_Vtr_Index>;
pub type OpenSubdiv_v3_6_1_Vtr_ConstIndexArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Vtr_Index>;
pub type OpenSubdiv_v3_6_1_Vtr_LocalIndexArray =
    OpenSubdiv_v3_6_1_Vtr_Array<OpenSubdiv_v3_6_1_Vtr_LocalIndex>;
pub type OpenSubdiv_v3_6_1_Vtr_ConstLocalIndexArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Vtr_LocalIndex>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_TriRefinement {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_QuadRefinement {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Level {
    pub _faceCount: ::std::os::raw::c_int,
    pub _edgeCount: ::std::os::raw::c_int,
    pub _vertCount: ::std::os::raw::c_int,
    pub _depth: ::std::os::raw::c_int,
    pub _maxEdgeFaces: ::std::os::raw::c_int,
    pub _maxValence: ::std::os::raw::c_int,
    pub _faceVertCountsAndOffsets: [u64; 3usize],
    pub _faceVertIndices: [u64; 3usize],
    pub _faceEdgeIndices: [u64; 3usize],
    pub _faceTags: [u64; 3usize],
    pub _edgeVertIndices: [u64; 3usize],
    pub _edgeFaceCountsAndOffsets: [u64; 3usize],
    pub _edgeFaceIndices: [u64; 3usize],
    pub _edgeFaceLocalIndices: [u64; 3usize],
    pub _edgeSharpness: [u64; 3usize],
    pub _edgeTags: [u64; 3usize],
    pub _vertFaceCountsAndOffsets: [u64; 3usize],
    pub _vertFaceIndices: [u64; 3usize],
    pub _vertFaceLocalIndices: [u64; 3usize],
    pub _vertEdgeCountsAndOffsets: [u64; 3usize],
    pub _vertEdgeIndices: [u64; 3usize],
    pub _vertEdgeLocalIndices: [u64; 3usize],
    pub _vertSharpness: [u64; 3usize],
    pub _vertTags: [u64; 3usize],
    pub _fvarChannels: [u64; 3usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize = ::std::os::raw::c_ushort;
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level4VTag9BitwiseOrEPKS4_i"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_BitwiseOr(
        vTags: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag,
        size: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag;
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
    #[inline]
    pub fn _nonManifold(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__nonManifold(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _xordinary(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__xordinary(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _boundary(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__boundary(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _corner(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__corner(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__infSharp(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _semiSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__semiSharp(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _semiSharpEdges(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__semiSharpEdges(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _rule(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set__rule(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _incomplete(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__incomplete(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _incidIrregFace(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__incidIrregFace(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infSharpEdges(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__infSharpEdges(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infSharpCrease(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__infSharpCrease(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infIrregular(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__infIrregular(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _nonManifold: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _xordinary: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _boundary: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _corner: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _infSharp: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _semiSharp: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _semiSharpEdges: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _rule: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _incomplete: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _incidIrregFace: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _infSharpEdges: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _infSharpCrease: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
        _infIrregular: OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_VTagSize,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _nonManifold: u16 = unsafe { ::std::mem::transmute(_nonManifold) };
            _nonManifold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _xordinary: u16 = unsafe { ::std::mem::transmute(_xordinary) };
            _xordinary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _boundary: u16 = unsafe { ::std::mem::transmute(_boundary) };
            _boundary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _corner: u16 = unsafe { ::std::mem::transmute(_corner) };
            _corner as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let _infSharp: u16 = unsafe { ::std::mem::transmute(_infSharp) };
            _infSharp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let _semiSharp: u16 = unsafe { ::std::mem::transmute(_semiSharp) };
            _semiSharp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let _semiSharpEdges: u16 = unsafe { ::std::mem::transmute(_semiSharpEdges) };
            _semiSharpEdges as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let _rule: u16 = unsafe { ::std::mem::transmute(_rule) };
            _rule as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let _incomplete: u16 = unsafe { ::std::mem::transmute(_incomplete) };
            _incomplete as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let _incidIrregFace: u16 = unsafe { ::std::mem::transmute(_incidIrregFace) };
            _incidIrregFace as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let _infSharpEdges: u16 = unsafe { ::std::mem::transmute(_infSharpEdges) };
            _infSharpEdges as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let _infSharpCrease: u16 = unsafe { ::std::mem::transmute(_infSharpCrease) };
            _infSharpCrease as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let _infIrregular: u16 = unsafe { ::std::mem::transmute(_infIrregular) };
            _infIrregular as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn BitwiseOr(
        vTags: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag,
        size: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag_BitwiseOr(vTags, size)
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize = ::std::os::raw::c_uchar;
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level4ETag9BitwiseOrEPKS4_i"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_BitwiseOr(
        eTags: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag,
        size: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag;
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag {
    #[inline]
    pub fn _nonManifold(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__nonManifold(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _boundary(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__boundary(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__infSharp(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _semiSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__semiSharp(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _nonManifold: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize,
        _boundary: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize,
        _infSharp: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize,
        _semiSharp: OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_ETagSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _nonManifold: u8 = unsafe { ::std::mem::transmute(_nonManifold) };
            _nonManifold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _boundary: u8 = unsafe { ::std::mem::transmute(_boundary) };
            _boundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _infSharp: u8 = unsafe { ::std::mem::transmute(_infSharp) };
            _infSharp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _semiSharp: u8 = unsafe { ::std::mem::transmute(_semiSharp) };
            _semiSharp as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn BitwiseOr(
        eTags: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag,
        size: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag_BitwiseOr(eTags, size)
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag_FTagSize = ::std::os::raw::c_uchar;
impl OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag {
    #[inline]
    pub fn _hole(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag_FTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__hole(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag_FTagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _hole: OpenSubdiv_v3_6_1_Vtr_internal_Level_FTag_FTagSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _hole: u8 = unsafe { ::std::mem::transmute(_hole) };
            _hole as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Level_VSpan {
    pub _numFaces: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    pub _startFace: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    pub _cornerInSpan: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Level_VSpan {
    #[inline]
    pub fn _periodic(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__periodic(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _sharp(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__sharp(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _periodic: ::std::os::raw::c_ushort,
        _sharp: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _periodic: u16 = unsafe { ::std::mem::transmute(_periodic) };
            _periodic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _sharp: u16 = unsafe { ::std::mem::transmute(_sharp) };
            _sharp as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_EDGE_FACES:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 0;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_EDGE_VERTS:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 1;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_FACE_EDGES:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 2;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_FACE_VERTS:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 3;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_VERT_FACES:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 4;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_MISSING_VERT_EDGES:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 5;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_CORRELATION_EDGE_FACE : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 6 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_CORRELATION_FACE_VERT : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 7 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_CORRELATION_FACE_EDGE : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 8 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_ORIENTATION_INCIDENT_EDGE : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 9 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_ORIENTATION_INCIDENT_FACE : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 10 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_FAILED_ORIENTATION_INCIDENT_FACES_EDGES : OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 11 ;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_DEGENERATE_EDGE:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 12;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_NON_MANIFOLD_EDGE:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 13;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_INVALID_CREASE_EDGE:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 14;
pub const OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError_TOPOLOGY_INVALID_CREASE_VERT:
    OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = 15;
pub type OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError = ::std::os::raw::c_uint;
pub type OpenSubdiv_v3_6_1_Vtr_internal_Level_ValidationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        errCode: OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError,
        msg: *const ::std::os::raw::c_char,
        clientData: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level8findEdgeEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_findEdge(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        v0Index: OpenSubdiv_v3_6_1_Vtr_Index,
        v1Index: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> OpenSubdiv_v3_6_1_Vtr_Index;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level14getFVarOptionsEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFVarOptions(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Options;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level16getNumFVarValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getNumFVarValues(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level17getFaceFVarValuesEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceFVarValues(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_ConstIndexArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level22getTopologyErrorStringENS3_13TopologyErrorE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getTopologyErrorString(
        errCode: OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level16validateTopologyEPFvNS3_13TopologyErrorEPKcPKvES8_"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_validateTopology(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        callback: OpenSubdiv_v3_6_1_Vtr_internal_Level_ValidationCallback,
        clientData: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level5printEPKNS2_10RefinementE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_print(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        parentRefinement: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level19isSingleCreasePatchEiPfPi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_isSingleCreasePatch(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        face: OpenSubdiv_v3_6_1_Vtr_Index,
        sharpnessOut: *mut f32,
        rotationOut: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level27doesVertexFVarTopologyMatchEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_doesVertexFVarTopologyMatch(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level25doesFaceFVarTopologyMatchEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_doesFaceFVarTopologyMatch(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level25doesEdgeFVarTopologyMatchEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_doesEdgeFVarTopologyMatch(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        eIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level12getFaceVTagsEiPNS3_4VTagEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceVTags(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag,
        fvarChannel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level12getFaceETagsEiPNS3_4ETagEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceETags(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        eTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag,
        fvarChannel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level20getFaceCompositeVTagEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceCompositeVTag(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level20getFaceCompositeVTagERNS1_10ConstArrayIiEE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceCompositeVTag1(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fVerts: *mut OpenSubdiv_v3_6_1_Vtr_ConstIndexArray,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level26getVertexCompositeFVarVTagEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getVertexCompositeFVarVTag(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level27gatherQuadLinearPatchPointsEiPiii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadLinearPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level36gatherQuadRegularInteriorPatchPointsEiPiii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularInteriorPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level36gatherQuadRegularBoundaryPatchPointsEiPiii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularBoundaryPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryEdgeInFace: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level34gatherQuadRegularCornerPatchPointsEiPiii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularCornerPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerVertInFace: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level33gatherQuadRegularRingAroundVertexEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularRingAroundVertex(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        ringPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level40gatherQuadRegularPartialRingAroundVertexEiRKNS3_5VSpanEPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularPartialRingAroundVertex(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        span: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_VSpan,
        ringPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level35gatherTriRegularInteriorPatchPointsEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularInteriorPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level41gatherTriRegularBoundaryVertexPatchPointsEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularBoundaryVertexPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryVertInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level39gatherTriRegularBoundaryEdgePatchPointsEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularBoundaryEdgePatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryEdgeInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level39gatherTriRegularCornerVertexPatchPointsEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularCornerVertexPatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerVertInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level37gatherTriRegularCornerEdgePatchPointsEiPii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularCornerEdgePatchPoints(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerEdgeInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level17createFVarChannelEiRKNS0_3Sdc7OptionsE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_createFVarChannel(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        fvarValueCount: ::std::os::raw::c_int,
        options: *const OpenSubdiv_v3_6_1_Sdc_Options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level18destroyFVarChannelEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_destroyFVarChannel(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level17getFaceFVarValuesEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceFVarValues1(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_IndexArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level27completeFVarChannelTopologyEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_completeFVarChannelTopology(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        channel: ::std::os::raw::c_int,
        regBoundaryValence: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level32completeTopologyFromFaceVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_completeTopologyFromFaceVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level8findEdgeEiiNS1_10ConstArrayIiEE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_findEdge1(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        v0: OpenSubdiv_v3_6_1_Vtr_Index,
        v1: OpenSubdiv_v3_6_1_Vtr_Index,
        v0Edges: OpenSubdiv_v3_6_1_Vtr_ConstIndexArray,
    ) -> OpenSubdiv_v3_6_1_Vtr_Index;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level24orientIncidentComponentsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_orientIncidentComponents(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level24orderVertexFacesAndEdgesEiPiS4_"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_orderVertexFacesAndEdges(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vFaces: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        vEdges: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level24orderVertexFacesAndEdgesEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_orderVertexFacesAndEdges1(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal5Level27testVertexNonManifoldCreaseEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_testVertexNonManifoldCrease(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5Level20populateLocalIndicesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_populateLocalIndices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5LevelC1Ev"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_Level(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal5LevelD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Level_Level_destructor(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    );
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Level {
    #[inline]
    pub unsafe fn findEdge(
        &self,
        v0Index: OpenSubdiv_v3_6_1_Vtr_Index,
        v1Index: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> OpenSubdiv_v3_6_1_Vtr_Index {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_findEdge(self, v0Index, v1Index)
    }
    #[inline]
    pub unsafe fn getFVarOptions(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Options {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFVarOptions(self, channel)
    }
    #[inline]
    pub unsafe fn getNumFVarValues(&self, channel: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getNumFVarValues(self, channel)
    }
    #[inline]
    pub unsafe fn getFaceFVarValues(
        &self,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_ConstIndexArray {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceFVarValues(self, faceIndex, channel)
    }
    #[inline]
    pub unsafe fn getTopologyErrorString(
        errCode: OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError,
    ) -> *const ::std::os::raw::c_char {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getTopologyErrorString(errCode)
    }
    #[inline]
    pub unsafe fn validateTopology(
        &self,
        callback: OpenSubdiv_v3_6_1_Vtr_internal_Level_ValidationCallback,
        clientData: *const ::std::os::raw::c_void,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_validateTopology(self, callback, clientData)
    }
    #[inline]
    pub unsafe fn print(&self, parentRefinement: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_print(self, parentRefinement)
    }
    #[inline]
    pub unsafe fn isSingleCreasePatch(
        &self,
        face: OpenSubdiv_v3_6_1_Vtr_Index,
        sharpnessOut: *mut f32,
        rotationOut: *mut ::std::os::raw::c_int,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_isSingleCreasePatch(
            self,
            face,
            sharpnessOut,
            rotationOut,
        )
    }
    #[inline]
    pub unsafe fn doesVertexFVarTopologyMatch(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_doesVertexFVarTopologyMatch(self, vIndex, fvarChannel)
    }
    #[inline]
    pub unsafe fn doesFaceFVarTopologyMatch(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_doesFaceFVarTopologyMatch(self, fIndex, fvarChannel)
    }
    #[inline]
    pub unsafe fn doesEdgeFVarTopologyMatch(
        &self,
        eIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_doesEdgeFVarTopologyMatch(self, eIndex, fvarChannel)
    }
    #[inline]
    pub unsafe fn getFaceVTags(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag,
        fvarChannel: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceVTags(self, fIndex, vTags, fvarChannel)
    }
    #[inline]
    pub unsafe fn getFaceETags(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        eTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level_ETag,
        fvarChannel: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceETags(self, fIndex, eTags, fvarChannel)
    }
    #[inline]
    pub unsafe fn getFaceCompositeVTag(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceCompositeVTag(self, fIndex, fvarChannel)
    }
    #[inline]
    pub unsafe fn getFaceCompositeVTag1(
        &self,
        fVerts: *mut OpenSubdiv_v3_6_1_Vtr_ConstIndexArray,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceCompositeVTag1(self, fVerts)
    }
    #[inline]
    pub unsafe fn getVertexCompositeFVarVTag(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_Level_VTag {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getVertexCompositeFVarVTag(self, vIndex, fvarChannel)
    }
    #[inline]
    pub unsafe fn gatherQuadLinearPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadLinearPatchPoints(
            self,
            fIndex,
            patchPoints,
            rotation,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherQuadRegularInteriorPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularInteriorPatchPoints(
            self,
            fIndex,
            patchPoints,
            rotation,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherQuadRegularBoundaryPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryEdgeInFace: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularBoundaryPatchPoints(
            self,
            fIndex,
            patchPoints,
            boundaryEdgeInFace,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherQuadRegularCornerPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerVertInFace: ::std::os::raw::c_int,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularCornerPatchPoints(
            self,
            fIndex,
            patchPoints,
            cornerVertInFace,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherQuadRegularRingAroundVertex(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        ringPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularRingAroundVertex(
            self,
            vIndex,
            ringPoints,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherQuadRegularPartialRingAroundVertex(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        span: *const OpenSubdiv_v3_6_1_Vtr_internal_Level_VSpan,
        ringPoints: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        fvarChannel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherQuadRegularPartialRingAroundVertex(
            self,
            vIndex,
            span,
            ringPoints,
            fvarChannel,
        )
    }
    #[inline]
    pub unsafe fn gatherTriRegularInteriorPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularInteriorPatchPoints(
            self, fIndex, patchVerts, rotation,
        )
    }
    #[inline]
    pub unsafe fn gatherTriRegularBoundaryVertexPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryVertInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularBoundaryVertexPatchPoints(
            self,
            fIndex,
            patchVerts,
            boundaryVertInFace,
        )
    }
    #[inline]
    pub unsafe fn gatherTriRegularBoundaryEdgePatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        boundaryEdgeInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularBoundaryEdgePatchPoints(
            self,
            fIndex,
            patchVerts,
            boundaryEdgeInFace,
        )
    }
    #[inline]
    pub unsafe fn gatherTriRegularCornerVertexPatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerVertInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularCornerVertexPatchPoints(
            self,
            fIndex,
            patchVerts,
            cornerVertInFace,
        )
    }
    #[inline]
    pub unsafe fn gatherTriRegularCornerEdgePatchPoints(
        &self,
        fIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        patchVerts: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        cornerEdgeInFace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_gatherTriRegularCornerEdgePatchPoints(
            self,
            fIndex,
            patchVerts,
            cornerEdgeInFace,
        )
    }
    #[inline]
    pub unsafe fn createFVarChannel(
        &mut self,
        fvarValueCount: ::std::os::raw::c_int,
        options: *const OpenSubdiv_v3_6_1_Sdc_Options,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_createFVarChannel(self, fvarValueCount, options)
    }
    #[inline]
    pub unsafe fn destroyFVarChannel(&mut self, channel: ::std::os::raw::c_int) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_destroyFVarChannel(self, channel)
    }
    #[inline]
    pub unsafe fn getFaceFVarValues1(
        &mut self,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Vtr_IndexArray {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_getFaceFVarValues1(self, faceIndex, channel)
    }
    #[inline]
    pub unsafe fn completeFVarChannelTopology(
        &mut self,
        channel: ::std::os::raw::c_int,
        regBoundaryValence: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_completeFVarChannelTopology(
            self,
            channel,
            regBoundaryValence,
        )
    }
    #[inline]
    pub unsafe fn completeTopologyFromFaceVertices(&mut self) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_completeTopologyFromFaceVertices(self)
    }
    #[inline]
    pub unsafe fn findEdge1(
        &self,
        v0: OpenSubdiv_v3_6_1_Vtr_Index,
        v1: OpenSubdiv_v3_6_1_Vtr_Index,
        v0Edges: OpenSubdiv_v3_6_1_Vtr_ConstIndexArray,
    ) -> OpenSubdiv_v3_6_1_Vtr_Index {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_findEdge1(self, v0, v1, v0Edges)
    }
    #[inline]
    pub unsafe fn orientIncidentComponents(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_orientIncidentComponents(self)
    }
    #[inline]
    pub unsafe fn orderVertexFacesAndEdges(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vFaces: *mut OpenSubdiv_v3_6_1_Vtr_Index,
        vEdges: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_orderVertexFacesAndEdges(self, vIndex, vFaces, vEdges)
    }
    #[inline]
    pub unsafe fn orderVertexFacesAndEdges1(
        &mut self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_orderVertexFacesAndEdges1(self, vIndex)
    }
    #[inline]
    pub unsafe fn testVertexNonManifoldCrease(&self, vIndex: OpenSubdiv_v3_6_1_Vtr_Index) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_testVertexNonManifoldCrease(self, vIndex)
    }
    #[inline]
    pub unsafe fn populateLocalIndices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_populateLocalIndices(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Vtr_internal_Level_Level(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Level_Level_destructor(self)
    }
}
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel {
    pub _level: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _options: OpenSubdiv_v3_6_1_Sdc_Options,
    pub _isLinear: bool,
    pub _hasLinearBoundaries: bool,
    pub _hasDependentSharpness: bool,
    pub _valueCount: ::std::os::raw::c_int,
    pub _faceVertValues: [u64; 3usize],
    pub _edgeTags: [u64; 3usize],
    pub _vertSiblingCounts: [u64; 3usize],
    pub _vertSiblingOffsets: [u64; 3usize],
    pub _vertFaceSiblings: [u64; 3usize],
    pub _vertValueIndices: [u64; 3usize],
    pub _vertValueTags: [u64; 3usize],
    pub _vertValueCreaseEnds: [u64; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize = ::std::os::raw::c_uchar;
impl OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag {
    #[inline]
    pub fn _mismatch(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__mismatch(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _disctsV0(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__disctsV0(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _disctsV1(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__disctsV1(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _linear(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__linear(&mut self, val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _mismatch: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize,
        _disctsV0: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize,
        _disctsV1: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize,
        _linear: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ETag_ETagSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _mismatch: u8 = unsafe { ::std::mem::transmute(_mismatch) };
            _mismatch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _disctsV0: u8 = unsafe { ::std::mem::transmute(_disctsV0) };
            _disctsV0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _disctsV1: u8 = unsafe { ::std::mem::transmute(_disctsV1) };
            _disctsV1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _linear: u8 = unsafe { ::std::mem::transmute(_linear) };
            _linear as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize = ::std::os::raw::c_uchar;
impl OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag {
    #[inline]
    pub fn _mismatch(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__mismatch(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _xordinary(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__xordinary(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _nonManifold(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__nonManifold(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _crease(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__crease(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _semiSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__semiSharp(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _depSharp(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__depSharp(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infSharpEdges(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__infSharpEdges(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _infIrregular(&self) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__infIrregular(
        &mut self,
        val: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _mismatch: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _xordinary: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _nonManifold: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _crease: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _semiSharp: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _depSharp: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _infSharpEdges: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
        _infIrregular: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag_ValueTagSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _mismatch: u8 = unsafe { ::std::mem::transmute(_mismatch) };
            _mismatch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _xordinary: u8 = unsafe { ::std::mem::transmute(_xordinary) };
            _xordinary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _nonManifold: u8 = unsafe { ::std::mem::transmute(_nonManifold) };
            _nonManifold as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _crease: u8 = unsafe { ::std::mem::transmute(_crease) };
            _crease as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let _semiSharp: u8 = unsafe { ::std::mem::transmute(_semiSharp) };
            _semiSharp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let _depSharp: u8 = unsafe { ::std::mem::transmute(_depSharp) };
            _depSharp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let _infSharpEdges: u8 = unsafe { ::std::mem::transmute(_infSharpEdges) };
            _infSharpEdges as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let _infIrregular: u8 = unsafe { ::std::mem::transmute(_infIrregular) };
            _infIrregular as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ConstValueTagArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag>;
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTagArray =
    OpenSubdiv_v3_6_1_Vtr_Array<OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_CreaseEndPair {
    pub _startFace: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    pub _endFace: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ConstCreaseEndPairArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_CreaseEndPair>;
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_CreaseEndPairArray =
    OpenSubdiv_v3_6_1_Vtr_Array<OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_CreaseEndPair>;
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_Sibling = OpenSubdiv_v3_6_1_Vtr_LocalIndex;
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ConstSiblingArray =
    OpenSubdiv_v3_6_1_Vtr_ConstLocalIndexArray;
pub type OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_SiblingArray =
    OpenSubdiv_v3_6_1_Vtr_LocalIndexArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueSpan {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel16getFaceValueTagsEiPNS3_8ValueTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getFaceValueTags(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        valueTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel24getFaceCompositeValueTagEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getFaceCompositeValueTag(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel17getEdgeFaceValuesEiiPi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getEdgeFaceValues(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        eIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fIncToEdge: ::std::os::raw::c_int,
        valuesPerVert: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel19getVertexEdgeValuesEiPi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getVertexEdgeValues(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        valuesPerEdge: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel24getVertexCreaseEndValuesEitPi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getVertexCreaseEndValues(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        sibling: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_Sibling,
        endValues: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel10setOptionsERKNS0_3Sdc7OptionsE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_setOptions(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        options: *const OpenSubdiv_v3_6_1_Sdc_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel18resizeVertexValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeVertexValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        numVertexValues: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel12resizeValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        numValues: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel16resizeComponentsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeComponents(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel30completeTopologyFromFaceValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_completeTopologyFromFaceValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        regBoundaryValence: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel36initializeFaceValuesFromFaceVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_initializeFaceValuesFromFaceVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel42initializeFaceValuesFromVertexFaceSiblingsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_initializeFaceValuesFromVertexFaceSiblings(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel16gatherValueSpansEiPNS3_9ValueSpanE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_gatherValueSpans(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vValueSpans: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueSpan,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel8validateEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_validate(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel5printEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_print(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal9FVarLevel45buildFaceVertexSiblingsFromVertexFaceSiblingsERSt6vectorItSaItEE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_buildFaceVertexSiblingsFromVertexFaceSiblings(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        fvSiblings: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevelC1ERKNS2_5LevelE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_FVarLevel(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        level: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal9FVarLevelD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_FVarLevel_destructor(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
impl OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel {
    #[inline]
    pub unsafe fn getFaceValueTags(
        &self,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        valueTags: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getFaceValueTags(self, faceIndex, valueTags)
    }
    #[inline]
    pub unsafe fn getFaceCompositeValueTag(
        &self,
        faceIndex: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueTag {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getFaceCompositeValueTag(self, faceIndex)
    }
    #[inline]
    pub unsafe fn getEdgeFaceValues(
        &self,
        eIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        fIncToEdge: ::std::os::raw::c_int,
        valuesPerVert: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getEdgeFaceValues(
            self,
            eIndex,
            fIncToEdge,
            valuesPerVert,
        )
    }
    #[inline]
    pub unsafe fn getVertexEdgeValues(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        valuesPerEdge: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getVertexEdgeValues(self, vIndex, valuesPerEdge)
    }
    #[inline]
    pub unsafe fn getVertexCreaseEndValues(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        sibling: OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_Sibling,
        endValues: *mut OpenSubdiv_v3_6_1_Vtr_Index,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_getVertexCreaseEndValues(
            self, vIndex, sibling, endValues,
        )
    }
    #[inline]
    pub unsafe fn setOptions(&mut self, options: *const OpenSubdiv_v3_6_1_Sdc_Options) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_setOptions(self, options)
    }
    #[inline]
    pub unsafe fn resizeVertexValues(&mut self, numVertexValues: ::std::os::raw::c_int) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeVertexValues(self, numVertexValues)
    }
    #[inline]
    pub unsafe fn resizeValues(&mut self, numValues: ::std::os::raw::c_int) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeValues(self, numValues)
    }
    #[inline]
    pub unsafe fn resizeComponents(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_resizeComponents(self)
    }
    #[inline]
    pub unsafe fn completeTopologyFromFaceValues(
        &mut self,
        regBoundaryValence: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_completeTopologyFromFaceValues(
            self,
            regBoundaryValence,
        )
    }
    #[inline]
    pub unsafe fn initializeFaceValuesFromFaceVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_initializeFaceValuesFromFaceVertices(self)
    }
    #[inline]
    pub unsafe fn initializeFaceValuesFromVertexFaceSiblings(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_initializeFaceValuesFromVertexFaceSiblings(self)
    }
    #[inline]
    pub unsafe fn gatherValueSpans(
        &self,
        vIndex: OpenSubdiv_v3_6_1_Vtr_Index,
        vValueSpans: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_ValueSpan,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_gatherValueSpans(self, vIndex, vValueSpans)
    }
    #[inline]
    pub unsafe fn validate(&self) -> bool {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_validate(self)
    }
    #[inline]
    pub unsafe fn print(&self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_print(self)
    }
    #[inline]
    pub unsafe fn buildFaceVertexSiblingsFromVertexFaceSiblings(
        &self,
        fvSiblings: *mut [u64; 3usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_buildFaceVertexSiblingsFromVertexFaceSiblings(
            self, fvSiblings,
        )
    }
    #[inline]
    pub unsafe fn new(level: *const OpenSubdiv_v3_6_1_Vtr_internal_Level) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_FVarLevel(__bindgen_tmp.as_mut_ptr(), level);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel_FVarLevel_destructor(self)
    }
}
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement {
    pub vtable_: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement__bindgen_vtable,
    pub _parent: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _child: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _options: OpenSubdiv_v3_6_1_Sdc_Options,
    pub _splitType: OpenSubdiv_v3_6_1_Sdc_Split,
    pub _regFaceSize: ::std::os::raw::c_int,
    pub _uniform: bool,
    pub _faceVertsFirst: bool,
    pub _childFaceFromFaceCount: ::std::os::raw::c_int,
    pub _childEdgeFromFaceCount: ::std::os::raw::c_int,
    pub _childEdgeFromEdgeCount: ::std::os::raw::c_int,
    pub _childVertFromFaceCount: ::std::os::raw::c_int,
    pub _childVertFromEdgeCount: ::std::os::raw::c_int,
    pub _childVertFromVertCount: ::std::os::raw::c_int,
    pub _firstChildFaceFromFace: ::std::os::raw::c_int,
    pub _firstChildEdgeFromFace: ::std::os::raw::c_int,
    pub _firstChildEdgeFromEdge: ::std::os::raw::c_int,
    pub _firstChildVertFromFace: ::std::os::raw::c_int,
    pub _firstChildVertFromEdge: ::std::os::raw::c_int,
    pub _firstChildVertFromVert: ::std::os::raw::c_int,
    pub _faceChildFaceCountsAndOffsets: OpenSubdiv_v3_6_1_Vtr_IndexArray,
    pub _faceChildEdgeCountsAndOffsets: OpenSubdiv_v3_6_1_Vtr_IndexArray,
    pub _faceChildFaceIndices: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _faceChildEdgeIndices: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _faceChildVertIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _edgeChildEdgeIndices: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _edgeChildVertIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _vertChildVertIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _childFaceParentIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _childEdgeParentIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _childVertexParentIndex: OpenSubdiv_v3_6_1_Vtr_IndexVector,
    pub _childFaceTag: [u64; 3usize],
    pub _childEdgeTag: [u64; 3usize],
    pub _childVertexTag: [u64; 3usize],
    pub _parentFaceTag: [u64; 3usize],
    pub _parentEdgeTag: [u64; 3usize],
    pub _parentVertexTag: [u64; 3usize],
    pub _fvarChannels: [u64; 3usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Options {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Options {
    #[inline]
    pub fn _sparse(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__sparse(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _faceVertsFirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__faceVertsFirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _minimalTopology(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__minimalTopology(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _sparse: ::std::os::raw::c_uint,
        _faceVertsFirst: ::std::os::raw::c_uint,
        _minimalTopology: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _sparse: u32 = unsafe { ::std::mem::transmute(_sparse) };
            _sparse as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _faceVertsFirst: u32 = unsafe { ::std::mem::transmute(_faceVertsFirst) };
            _faceVertsFirst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _minimalTopology: u32 = unsafe { ::std::mem::transmute(_minimalTopology) };
            _minimalTopology as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement_SparseTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Refinement_SparseTag {
    #[inline]
    pub fn _selected(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__selected(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _transitional(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__transitional(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _selected: ::std::os::raw::c_uchar,
        _transitional: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _selected: u8 = unsafe { ::std::mem::transmute(_selected) };
            _selected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let _transitional: u8 = unsafe { ::std::mem::transmute(_transitional) };
            _transitional as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag {
    #[inline]
    pub fn _incomplete(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__incomplete(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _parentType(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__parentType(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn _indexInParent(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__indexInParent(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _incomplete: ::std::os::raw::c_uchar,
        _parentType: ::std::os::raw::c_uchar,
        _indexInParent: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _incomplete: u8 = unsafe { ::std::mem::transmute(_incomplete) };
            _incomplete as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let _parentType: u8 = unsafe { ::std::mem::transmute(_parentType) };
            _parentType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let _indexInParent: u8 = unsafe { ::std::mem::transmute(_indexInParent) };
            _indexInParent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Relations {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Relations {
    #[inline]
    pub fn _faceVertices(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__faceVertices(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _faceEdges(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__faceEdges(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _edgeVertices(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__edgeVertices(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _edgeFaces(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__edgeFaces(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _vertexFaces(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__vertexFaces(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _vertexEdges(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__vertexEdges(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _faceVertices: ::std::os::raw::c_uint,
        _faceEdges: ::std::os::raw::c_uint,
        _edgeVertices: ::std::os::raw::c_uint,
        _edgeFaces: ::std::os::raw::c_uint,
        _vertexFaces: ::std::os::raw::c_uint,
        _vertexEdges: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _faceVertices: u32 = unsafe { ::std::mem::transmute(_faceVertices) };
            _faceVertices as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _faceEdges: u32 = unsafe { ::std::mem::transmute(_faceEdges) };
            _faceEdges as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _edgeVertices: u32 = unsafe { ::std::mem::transmute(_edgeVertices) };
            _edgeVertices as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _edgeFaces: u32 = unsafe { ::std::mem::transmute(_edgeFaces) };
            _edgeFaces as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let _vertexFaces: u32 = unsafe { ::std::mem::transmute(_vertexFaces) };
            _vertexFaces as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let _vertexEdges: u32 = unsafe { ::std::mem::transmute(_vertexEdges) };
            _vertexEdges as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement6refineENS3_7OptionsE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_refine(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        options: OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement28populateParentToChildMappingEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateParentToChildMapping(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement26populateParentChildIndicesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateParentChildIndices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal10Refinement25printParentToChildMappingEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_printParentToChildMapping(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement29initializeSparseSelectionTagsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_initializeSparseSelectionTags(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement31markSparseChildComponentIndicesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseChildComponentIndices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement24markSparseVertexChildrenEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseVertexChildren(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement22markSparseEdgeChildrenEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseEdgeChildren(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement30initializeChildComponentCountsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_initializeChildComponentCounts(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement28populateChildToParentMappingEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateChildToParentMapping(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement25populateFaceParentVectorsEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceParentVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement33populateFaceParentFromParentFacesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceParentFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement25populateEdgeParentVectorsEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement33populateEdgeParentFromParentFacesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement33populateEdgeParentFromParentEdgesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentFromParentEdges(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement27populateVertexParentVectorsEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement35populateVertexParentFromParentFacesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement35populateVertexParentFromParentEdgesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentEdges(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement38populateVertexParentFromParentVerticesEPA4_KNS3_8ChildTagE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement22propagateComponentTagsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_propagateComponentTags(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement22populateFaceTagVectorsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceTagVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement31populateFaceTagsFromParentFacesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceTagsFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement22populateEdgeTagVectorsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement31populateEdgeTagsFromParentFacesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagsFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement31populateEdgeTagsFromParentEdgesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagsFromParentEdges(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement24populateVertexTagVectorsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagVectors(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement33populateVertexTagsFromParentFacesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentFaces(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement33populateVertexTagsFromParentEdgesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentEdges(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement36populateVertexTagsFromParentVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement17subdivideTopologyERKNS3_9RelationsE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideTopology(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        relationsToSubdivide: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Relations,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement24subdivideSharpnessValuesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideSharpnessValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement24subdivideVertexSharpnessEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideVertexSharpness(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement22subdivideEdgeSharpnessEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideEdgeSharpness(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement27reclassifySemisharpVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_reclassifySemisharpVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10Refinement21subdivideFVarChannelsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideFVarChannels(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10RefinementC2ERKNS2_5LevelERS4_RKNS0_3Sdc7OptionsE"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Refinement(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        parent: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        child: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        schemeOptions: *const OpenSubdiv_v3_6_1_Sdc_Options,
    );
}
impl OpenSubdiv_v3_6_1_Vtr_internal_Refinement {
    #[inline]
    pub unsafe fn refine(&mut self, options: OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Options) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_refine(self, options)
    }
    #[inline]
    pub unsafe fn populateParentToChildMapping(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateParentToChildMapping(self)
    }
    #[inline]
    pub unsafe fn populateParentChildIndices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateParentChildIndices(self)
    }
    #[inline]
    pub unsafe fn printParentToChildMapping(&self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_printParentToChildMapping(self)
    }
    #[inline]
    pub unsafe fn initializeSparseSelectionTags(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_initializeSparseSelectionTags(self)
    }
    #[inline]
    pub unsafe fn markSparseChildComponentIndices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseChildComponentIndices(self)
    }
    #[inline]
    pub unsafe fn markSparseVertexChildren(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseVertexChildren(self)
    }
    #[inline]
    pub unsafe fn markSparseEdgeChildren(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_markSparseEdgeChildren(self)
    }
    #[inline]
    pub unsafe fn initializeChildComponentCounts(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_initializeChildComponentCounts(self)
    }
    #[inline]
    pub unsafe fn populateChildToParentMapping(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateChildToParentMapping(self)
    }
    #[inline]
    pub unsafe fn populateFaceParentVectors(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceParentVectors(self, initialChildTags)
    }
    #[inline]
    pub unsafe fn populateFaceParentFromParentFaces(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceParentFromParentFaces(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateEdgeParentVectors(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentVectors(self, initialChildTags)
    }
    #[inline]
    pub unsafe fn populateEdgeParentFromParentFaces(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentFromParentFaces(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateEdgeParentFromParentEdges(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeParentFromParentEdges(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateVertexParentVectors(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentVectors(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateVertexParentFromParentFaces(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentFaces(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateVertexParentFromParentEdges(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentEdges(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn populateVertexParentFromParentVertices(
        &mut self,
        initialChildTags: *const [OpenSubdiv_v3_6_1_Vtr_internal_Refinement_ChildTag; 4usize],
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexParentFromParentVertices(
            self,
            initialChildTags,
        )
    }
    #[inline]
    pub unsafe fn propagateComponentTags(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_propagateComponentTags(self)
    }
    #[inline]
    pub unsafe fn populateFaceTagVectors(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceTagVectors(self)
    }
    #[inline]
    pub unsafe fn populateFaceTagsFromParentFaces(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateFaceTagsFromParentFaces(self)
    }
    #[inline]
    pub unsafe fn populateEdgeTagVectors(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagVectors(self)
    }
    #[inline]
    pub unsafe fn populateEdgeTagsFromParentFaces(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagsFromParentFaces(self)
    }
    #[inline]
    pub unsafe fn populateEdgeTagsFromParentEdges(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateEdgeTagsFromParentEdges(self)
    }
    #[inline]
    pub unsafe fn populateVertexTagVectors(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagVectors(self)
    }
    #[inline]
    pub unsafe fn populateVertexTagsFromParentFaces(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentFaces(self)
    }
    #[inline]
    pub unsafe fn populateVertexTagsFromParentEdges(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentEdges(self)
    }
    #[inline]
    pub unsafe fn populateVertexTagsFromParentVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_populateVertexTagsFromParentVertices(self)
    }
    #[inline]
    pub unsafe fn subdivideTopology(
        &mut self,
        relationsToSubdivide: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Relations,
    ) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideTopology(self, relationsToSubdivide)
    }
    #[inline]
    pub unsafe fn subdivideSharpnessValues(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideSharpnessValues(self)
    }
    #[inline]
    pub unsafe fn subdivideVertexSharpness(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideVertexSharpness(self)
    }
    #[inline]
    pub unsafe fn subdivideEdgeSharpness(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideEdgeSharpness(self)
    }
    #[inline]
    pub unsafe fn reclassifySemisharpVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_reclassifySemisharpVertices(self)
    }
    #[inline]
    pub unsafe fn subdivideFVarChannels(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_subdivideFVarChannels(self)
    }
    #[inline]
    pub unsafe fn new(
        parent: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
        child: *mut OpenSubdiv_v3_6_1_Vtr_internal_Level,
        schemeOptions: *const OpenSubdiv_v3_6_1_Sdc_Options,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Refinement(
            __bindgen_tmp.as_mut_ptr(),
            parent,
            child,
            schemeOptions,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal10RefinementD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_Refinement_Refinement_destructor(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    );
}
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement {
    pub _refinement: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    pub _parentLevel: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _parentFVar: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    pub _childLevel: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _childFVar: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    pub _childValueParentSource: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement19getFractionalWeightEitit"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_getFractionalWeight(
        this: *const OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
        pVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pSibling: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        cSibling: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement15applyRefinementEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_applyRefinement(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement30estimateAndAllocateChildValuesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_estimateAndAllocateChildValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement19populateChildValuesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement35populateChildValuesFromFaceVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromFaceVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement35populateChildValuesFromEdgeVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromEdgeVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement32populateChildValuesForEdgeVertexEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesForEdgeVertex(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pEdge: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement37populateChildValuesFromVertexVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromVertexVertices(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement34populateChildValuesForVertexVertexEii"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesForVertexVertex(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pVert: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement26trimAndFinalizeChildValuesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_trimAndFinalizeChildValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement17propagateEdgeTagsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateEdgeTags(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement18propagateValueTagsEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateValueTags(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement21propagateValueCreasesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateValueCreases(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinement25reclassifySemisharpValuesEv"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_reclassifySemisharpValues(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinementC1ERKNS2_10RefinementERNS2_9FVarLevelES8_"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_FVarRefinement(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
        refinement: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        parent: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        child: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Vtr8internal14FVarRefinementD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_FVarRefinement_destructor(
        this: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement,
    );
}
impl OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement {
    #[inline]
    pub unsafe fn getFractionalWeight(
        &self,
        pVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pSibling: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        cSibling: OpenSubdiv_v3_6_1_Vtr_LocalIndex,
    ) -> f32 {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_getFractionalWeight(
            self, pVert, pSibling, cVert, cSibling,
        )
    }
    #[inline]
    pub unsafe fn applyRefinement(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_applyRefinement(self)
    }
    #[inline]
    pub unsafe fn estimateAndAllocateChildValues(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_estimateAndAllocateChildValues(self)
    }
    #[inline]
    pub unsafe fn populateChildValues(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValues(self)
    }
    #[inline]
    pub unsafe fn populateChildValuesFromFaceVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromFaceVertices(self)
    }
    #[inline]
    pub unsafe fn populateChildValuesFromEdgeVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromEdgeVertices(self)
    }
    #[inline]
    pub unsafe fn populateChildValuesForEdgeVertex(
        &mut self,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pEdge: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesForEdgeVertex(
            self, cVert, pEdge,
        )
    }
    #[inline]
    pub unsafe fn populateChildValuesFromVertexVertices(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesFromVertexVertices(self)
    }
    #[inline]
    pub unsafe fn populateChildValuesForVertexVertex(
        &mut self,
        cVert: OpenSubdiv_v3_6_1_Vtr_Index,
        pVert: OpenSubdiv_v3_6_1_Vtr_Index,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_populateChildValuesForVertexVertex(
            self, cVert, pVert,
        )
    }
    #[inline]
    pub unsafe fn trimAndFinalizeChildValues(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_trimAndFinalizeChildValues(self)
    }
    #[inline]
    pub unsafe fn propagateEdgeTags(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateEdgeTags(self)
    }
    #[inline]
    pub unsafe fn propagateValueTags(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateValueTags(self)
    }
    #[inline]
    pub unsafe fn propagateValueCreases(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_propagateValueCreases(self)
    }
    #[inline]
    pub unsafe fn reclassifySemisharpValues(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_reclassifySemisharpValues(self)
    }
    #[inline]
    pub unsafe fn new(
        refinement: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
        parent: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
        child: *mut OpenSubdiv_v3_6_1_Vtr_internal_FVarLevel,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_FVarRefinement(
            __bindgen_tmp.as_mut_ptr(),
            refinement,
            parent,
            child,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        OpenSubdiv_v3_6_1_Vtr_internal_FVarRefinement_FVarRefinement_destructor(self)
    }
}
pub type OpenSubdiv_v3_6_1_Vtr_internal_StackBuffer_size_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_FaceInterface {
    pub _vertCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_EdgeInterface {
    pub _level: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _eIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_VertexInterface {
    pub _parent: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _child: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _pIndex: ::std::os::raw::c_int,
    pub _cIndex: ::std::os::raw::c_int,
    pub _eCount: ::std::os::raw::c_int,
    pub _fCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Vtr_internal_SparseSelector {
    _unused: [u8; 0],
}
pub type OpenSubdiv_v3_6_1_Far_Index = OpenSubdiv_v3_6_1_Vtr_Index;
pub type OpenSubdiv_v3_6_1_Far_LocalIndex = OpenSubdiv_v3_6_1_Vtr_LocalIndex;
pub type OpenSubdiv_v3_6_1_Far_IndexArray = OpenSubdiv_v3_6_1_Vtr_IndexArray;
pub type OpenSubdiv_v3_6_1_Far_LocalIndexArray = OpenSubdiv_v3_6_1_Vtr_LocalIndexArray;
pub type OpenSubdiv_v3_6_1_Far_ConstIndexArray = OpenSubdiv_v3_6_1_Vtr_ConstIndexArray;
pub type OpenSubdiv_v3_6_1_Far_ConstLocalIndexArray = OpenSubdiv_v3_6_1_Vtr_ConstLocalIndexArray;
#[doc = "< No error. Move along."]
pub const OpenSubdiv_v3_6_1_Far_ErrorType_FAR_NO_ERROR: OpenSubdiv_v3_6_1_Far_ErrorType = 0;
#[doc = "< Issue a fatal error and end the program."]
pub const OpenSubdiv_v3_6_1_Far_ErrorType_FAR_FATAL_ERROR: OpenSubdiv_v3_6_1_Far_ErrorType = 1;
#[doc = "< Issue an internal programming error, but continue execution."]
pub const OpenSubdiv_v3_6_1_Far_ErrorType_FAR_INTERNAL_CODING_ERROR:
    OpenSubdiv_v3_6_1_Far_ErrorType = 2;
#[doc = "< Issue a generic programming error, but continue execution."]
pub const OpenSubdiv_v3_6_1_Far_ErrorType_FAR_CODING_ERROR: OpenSubdiv_v3_6_1_Far_ErrorType = 3;
#[doc = "< Issue a generic runtime error, but continue execution."]
pub const OpenSubdiv_v3_6_1_Far_ErrorType_FAR_RUNTIME_ERROR: OpenSubdiv_v3_6_1_Far_ErrorType = 4;
pub type OpenSubdiv_v3_6_1_Far_ErrorType = ::std::os::raw::c_uint;
#[doc = " \\brief The error callback function type (default is \"printf\")"]
pub type OpenSubdiv_v3_6_1_Far_ErrorCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        err: OpenSubdiv_v3_6_1_Far_ErrorType,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " \\brief The warning callback function type (default is \"printf\")"]
pub type OpenSubdiv_v3_6_1_Far_WarningCallbackFunc =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[doc = "\n \\brief An interface for accessing data in a specific level of a refined topology hierarchy.\n\n TopologyLevel provides an interface to data in a specific level of a topology hierarchy.\n Instances of TopologyLevel are created and owned by a TopologyRefiner,\n which will return const-references to them.  Such references are only valid during the\n lifetime of the TopologyRefiner that created and returned them, and only for a given refinement,\n i.e. if the TopologyRefiner is re-refined, any references to TopoologyLevels are invalidated.\n"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyLevel {
    pub _level: *const OpenSubdiv_v3_6_1_Vtr_internal_Level,
    pub _refToParent: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
    pub _refToChild: *const OpenSubdiv_v3_6_1_Vtr_internal_Refinement,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Far_internal_FeatureMask {
    _unused: [u8; 0],
}
#[doc = "\n  \\brief Stores topology data for a specified set of refinement options.\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefiner {
    pub _subdivType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    pub _subdivOptions: OpenSubdiv_v3_6_1_Sdc_Options,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub _uniformOptions: OpenSubdiv_v3_6_1_Far_TopologyRefiner_UniformOptions,
    pub _adaptiveOptions: OpenSubdiv_v3_6_1_Far_TopologyRefiner_AdaptiveOptions,
    pub _totalVertices: ::std::os::raw::c_int,
    pub _totalEdges: ::std::os::raw::c_int,
    pub _totalFaces: ::std::os::raw::c_int,
    pub _totalFaceVertices: ::std::os::raw::c_int,
    pub _maxValence: ::std::os::raw::c_int,
    pub _baseLevelOwned: bool,
    pub _levels: [u64; 3usize],
    pub _refinements: [u64; 3usize],
    pub _farLevels: [u64; 3usize],
}
#[doc = " \\brief Uniform refinement options\n\n Options for uniform refinement, including the number of levels, vertex\n ordering and generation of topology information.\n\n Note the impact of the option to generate fullTopologyInLastLevel.  Given\n subsequent levels of uniform refinement typically reguire 4x the data\n of the previous level, only the minimum amount of data is generated in the\n last level by default, i.e. a vertex and face-vertex list.  If requiring\n topology traversal of the last level, e.g. inspecting edges or incident\n faces of vertices, the option to generate full topology in the last\n level should be enabled.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefiner_UniformOptions {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl OpenSubdiv_v3_6_1_Far_TopologyRefiner_UniformOptions {
    #[inline]
    pub fn refinementLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_refinementLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn orderVerticesFromFacesFirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_orderVerticesFromFacesFirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fullTopologyInLastLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fullTopologyInLastLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refinementLevel: ::std::os::raw::c_uint,
        orderVerticesFromFacesFirst: ::std::os::raw::c_uint,
        fullTopologyInLastLevel: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let refinementLevel: u32 = unsafe { ::std::mem::transmute(refinementLevel) };
            refinementLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let orderVerticesFromFacesFirst: u32 =
                unsafe { ::std::mem::transmute(orderVerticesFromFacesFirst) };
            orderVerticesFromFacesFirst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fullTopologyInLastLevel: u32 =
                unsafe { ::std::mem::transmute(fullTopologyInLastLevel) };
            fullTopologyInLastLevel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\brief Adaptive refinement options"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefiner_AdaptiveOptions {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl OpenSubdiv_v3_6_1_Far_TopologyRefiner_AdaptiveOptions {
    #[inline]
    pub fn isolationLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_isolationLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondaryLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondaryLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn useSingleCreasePatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useSingleCreasePatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useInfSharpPatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useInfSharpPatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn considerFVarChannels(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_considerFVarChannels(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn orderVerticesFromFacesFirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_orderVerticesFromFacesFirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isolationLevel: ::std::os::raw::c_uint,
        secondaryLevel: ::std::os::raw::c_uint,
        useSingleCreasePatch: ::std::os::raw::c_uint,
        useInfSharpPatch: ::std::os::raw::c_uint,
        considerFVarChannels: ::std::os::raw::c_uint,
        orderVerticesFromFacesFirst: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let isolationLevel: u32 = unsafe { ::std::mem::transmute(isolationLevel) };
            isolationLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let secondaryLevel: u32 = unsafe { ::std::mem::transmute(secondaryLevel) };
            secondaryLevel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let useSingleCreasePatch: u32 = unsafe { ::std::mem::transmute(useSingleCreasePatch) };
            useSingleCreasePatch as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let useInfSharpPatch: u32 = unsafe { ::std::mem::transmute(useInfSharpPatch) };
            useInfSharpPatch as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let considerFVarChannels: u32 = unsafe { ::std::mem::transmute(considerFVarChannels) };
            considerFVarChannels as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let orderVerticesFromFacesFirst: u32 =
                unsafe { ::std::mem::transmute(orderVerticesFromFacesFirst) };
            orderVerticesFromFacesFirst as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " \\brief Refine the topology uniformly\n\n This method applies uniform refinement to the level specified in the\n given UniformOptions.\n\n Note the impact of the UniformOption to generate fullTopologyInLastLevel\n and be sure it is assigned to satisfy the needs of the resulting refinement.\n\n @param options   Options controlling uniform refinement\n"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefiner13RefineUniformENS2_14UniformOptionsE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_RefineUniform(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        options: OpenSubdiv_v3_6_1_Far_TopologyRefiner_UniformOptions,
    );
}
extern "C" {
    #[doc = " \\brief Feature Adaptive topology refinement\n\n @param options         Options controlling adaptive refinement\n\n @param selectedFaces   Limit adaptive refinement to the specified faces\n"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefiner14RefineAdaptiveENS2_15AdaptiveOptionsENS0_3Vtr10ConstArrayIiEE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_RefineAdaptive(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        options: OpenSubdiv_v3_6_1_Far_TopologyRefiner_AdaptiveOptions,
        selectedFaces: OpenSubdiv_v3_6_1_Far_ConstIndexArray,
    );
}
extern "C" {
    #[doc = " \\brief Unrefine the topology, keeping only the base level."]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefiner8UnrefineEv"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_Unrefine(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    );
}
extern "C" {
    #[doc = " \\brief Returns the total number of face-varying values in all levels"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far15TopologyRefiner21GetNumFVarValuesTotalEi"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_GetNumFVarValuesTotal(
        this: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Constructor"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefinerC1ENS0_3Sdc10SchemeTypeENS3_7OptionsE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        type_: OpenSubdiv_v3_6_1_Sdc_SchemeType,
        options: OpenSubdiv_v3_6_1_Sdc_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefinerC1ERKS2_"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner1(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        source: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    );
}
extern "C" {
    #[doc = " \\brief Destructor"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15TopologyRefinerD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner_destructor(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    );
}
impl OpenSubdiv_v3_6_1_Far_TopologyRefiner {
    #[inline]
    pub fn _isUniform(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__isUniform(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _hasHoles(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__hasHoles(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _hasIrregFaces(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__hasIrregFaces(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _regFaceSize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set__regFaceSize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn _maxLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__maxLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _isUniform: ::std::os::raw::c_uint,
        _hasHoles: ::std::os::raw::c_uint,
        _hasIrregFaces: ::std::os::raw::c_uint,
        _regFaceSize: ::std::os::raw::c_uint,
        _maxLevel: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _isUniform: u32 = unsafe { ::std::mem::transmute(_isUniform) };
            _isUniform as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _hasHoles: u32 = unsafe { ::std::mem::transmute(_hasHoles) };
            _hasHoles as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _hasIrregFaces: u32 = unsafe { ::std::mem::transmute(_hasIrregFaces) };
            _hasIrregFaces as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let _regFaceSize: u32 = unsafe { ::std::mem::transmute(_regFaceSize) };
            _regFaceSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let _maxLevel: u32 = unsafe { ::std::mem::transmute(_maxLevel) };
            _maxLevel as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn RefineUniform(
        &mut self,
        options: OpenSubdiv_v3_6_1_Far_TopologyRefiner_UniformOptions,
    ) {
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_RefineUniform(self, options)
    }
    #[inline]
    pub unsafe fn RefineAdaptive(
        &mut self,
        options: OpenSubdiv_v3_6_1_Far_TopologyRefiner_AdaptiveOptions,
        selectedFaces: OpenSubdiv_v3_6_1_Far_ConstIndexArray,
    ) {
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_RefineAdaptive(self, options, selectedFaces)
    }
    #[inline]
    pub unsafe fn Unrefine(&mut self) {
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_Unrefine(self)
    }
    #[inline]
    pub unsafe fn GetNumFVarValuesTotal(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_GetNumFVarValuesTotal(self, channel)
    }
    #[inline]
    pub unsafe fn new(
        type_: OpenSubdiv_v3_6_1_Sdc_SchemeType,
        options: OpenSubdiv_v3_6_1_Sdc_Options,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner(
            __bindgen_tmp.as_mut_ptr(),
            type_,
            options,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(source: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner1(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        OpenSubdiv_v3_6_1_Far_TopologyRefiner_TopologyRefiner_destructor(self)
    }
}
#[doc = "\n  \\brief Applies refinement operations to generic primvar data.\n"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal {
    pub _refiner: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner,
}
pub type OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Weight<REAL> = REAL;
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Mask<REAL> {
    pub _vertWeights: *mut OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Mask_Weight<REAL>,
    pub _edgeWeights: *mut OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Mask_Weight<REAL>,
    pub _faceWeights: *mut OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Mask_Weight<REAL>,
    pub _vertCount: ::std::os::raw::c_int,
    pub _edgeCount: ::std::os::raw::c_int,
    pub _faceCount: ::std::os::raw::c_int,
    pub _faceWeightsForFaceCenters: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<REAL>>,
}
pub type OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal_Mask_Weight<REAL> = REAL;
#[repr(C)]
#[derive(Debug, PartialEq)]
pub struct OpenSubdiv_v3_6_1_Far_PrimvarRefiner {
    pub _base: OpenSubdiv_v3_6_1_Far_PrimvarRefinerReal,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTableBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_StencilTableFactoryReal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_LimitStencilTableFactoryReal {
    pub _address: u8,
}
#[doc = " \\brief Vertex stencil descriptor\n\n Allows access and manipulation of a single stencil in a StencilTable.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_StencilReal<REAL> {
    pub _size: *mut ::std::os::raw::c_int,
    pub _indices: *mut OpenSubdiv_v3_6_1_Far_Index,
    pub _weights: *mut REAL,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<REAL>>,
}
#[doc = " \\brief Vertex stencil class wrapping the template for compatibility.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct OpenSubdiv_v3_6_1_Far_Stencil {
    pub _base: OpenSubdiv_v3_6_1_Far_StencilReal<f32>,
}
#[doc = " \\brief Vertex stencil descriptor\n\n Allows access and manipulation of a single stencil in a StencilTable.\n"]
pub type OpenSubdiv_v3_6_1_Far_Stencil_BaseStencil = OpenSubdiv_v3_6_1_Far_StencilReal<f32>;
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_StencilTableReal__bindgen_vtable(::std::os::raw::c_void);
#[doc = " \\brief Table of subdivision stencils.\n\n Stencils are the most direct method of evaluation of locations on the limit\n of a surface. Every point of a limit surface can be computed by linearly\n blending a collection of coarse control vertices.\n\n A stencil assigns a series of control vertex indices with a blending weight\n that corresponds to a unique parametric location of the limit surface. When\n the control vertices move in space, the limit location can be very efficiently\n recomputed simply by applying the blending weights to the series of coarse\n control vertices.\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_StencilTableReal {
    pub vtable_: *const OpenSubdiv_v3_6_1_Far_StencilTableReal__bindgen_vtable,
    pub _numControlVertices: ::std::os::raw::c_int,
    pub _sizes: [u64; 3usize],
    pub _offsets: [u64; 3usize],
    pub _indices: [u64; 3usize],
    pub _weights: u8<_Tp, _Alloc>,
}
#[doc = " \\brief Stencil table class wrapping the template for compatibility.\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_StencilTable {
    pub _base: OpenSubdiv_v3_6_1_Far_StencilTableReal,
}
#[doc = " \\brief Table of subdivision stencils.\n\n Stencils are the most direct method of evaluation of locations on the limit\n of a surface. Every point of a limit surface can be computed by linearly\n blending a collection of coarse control vertices.\n\n A stencil assigns a series of control vertex indices with a blending weight\n that corresponds to a unique parametric location of the limit surface. When\n the control vertices move in space, the limit location can be very efficiently\n recomputed simply by applying the blending weights to the series of coarse\n control vertices.\n"]
pub type OpenSubdiv_v3_6_1_Far_StencilTable_BaseTable = OpenSubdiv_v3_6_1_Far_StencilTableReal;
#[doc = " \\brief Limit point stencil descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_LimitStencilReal<REAL> {
    pub _base: OpenSubdiv_v3_6_1_Far_StencilReal<REAL>,
    pub _duWeights: *mut REAL,
    pub _dvWeights: *mut REAL,
    pub _duuWeights: *mut REAL,
    pub _duvWeights: *mut REAL,
    pub _dvvWeights: *mut REAL,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<REAL>>,
}
#[doc = " \\brief Limit point stencil class wrapping the template for compatibility.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct OpenSubdiv_v3_6_1_Far_LimitStencil {
    pub _base: OpenSubdiv_v3_6_1_Far_LimitStencilReal<f32>,
}
#[doc = " \\brief Limit point stencil descriptor\n"]
pub type OpenSubdiv_v3_6_1_Far_LimitStencil_BaseStencil =
    OpenSubdiv_v3_6_1_Far_LimitStencilReal<f32>;
#[doc = " \\brief Table of limit subdivision stencils.\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_LimitStencilTableReal {
    pub _base: OpenSubdiv_v3_6_1_Far_StencilTableReal,
    pub _duWeights: u8<_Tp, _Alloc>,
    pub _dvWeights: u8<_Tp, _Alloc>,
    pub _duuWeights: u8<_Tp, _Alloc>,
    pub _duvWeights: u8<_Tp, _Alloc>,
    pub _dvvWeights: u8<_Tp, _Alloc>,
}
#[doc = " \\brief Limit stencil table class wrapping the template for compatibility.\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_LimitStencilTable {
    pub _base: OpenSubdiv_v3_6_1_Far_LimitStencilTableReal,
}
#[doc = " \\brief Table of limit subdivision stencils.\n"]
pub type OpenSubdiv_v3_6_1_Far_LimitStencilTable_BaseTable =
    OpenSubdiv_v3_6_1_Far_LimitStencilTableReal;
#[doc = "\\brief Private base class of Factories for constructing TopologyRefiners\n\n TopologyRefinerFactoryBase is the base class for subclasses that are intended to\n construct TopologyRefiners directly from meshes in their native representations.\n The subclasses are parameterized by the mesh type \\<class MESH\\> and are expected\n to inherit the details related to assembly and validation provided here that are\n independent of the subclass' mesh type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase {
    pub _address: u8,
}
pub type OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_TopologyCallback =
    OpenSubdiv_v3_6_1_Vtr_internal_Level_ValidationCallback;
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far26TopologyRefinerFactoryBase30prepareComponentTopologySizingERNS1_15TopologyRefinerE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTopologySizing(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far26TopologyRefinerFactoryBase34prepareComponentTopologyAssignmentERNS1_15TopologyRefinerEbPFvNS0_3Vtr8internal5Level13TopologyErrorEPKcPKvESC_"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTopologyAssignment(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        fullValidation: bool,
        callback: OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_TopologyCallback,
        callbackData: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far26TopologyRefinerFactoryBase32prepareComponentTagsAndSharpnessERNS1_15TopologyRefinerE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTagsAndSharpness(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far26TopologyRefinerFactoryBase26prepareFaceVaryingChannelsERNS1_15TopologyRefinerE"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareFaceVaryingChannels(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool;
}
impl OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase {
    #[inline]
    pub unsafe fn prepareComponentTopologySizing(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool {
        OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTopologySizing(refiner)
    }
    #[inline]
    pub unsafe fn prepareComponentTopologyAssignment(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        fullValidation: bool,
        callback: OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_TopologyCallback,
        callbackData: *const ::std::os::raw::c_void,
    ) -> bool {
        OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTopologyAssignment(
            refiner,
            fullValidation,
            callback,
            callbackData,
        )
    }
    #[inline]
    pub unsafe fn prepareComponentTagsAndSharpness(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool {
        OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareComponentTagsAndSharpness(refiner)
    }
    #[inline]
    pub unsafe fn prepareFaceVaryingChannels(
        refiner: *mut OpenSubdiv_v3_6_1_Far_TopologyRefiner,
    ) -> bool {
        OpenSubdiv_v3_6_1_Far_TopologyRefinerFactoryBase_prepareFaceVaryingChannels(refiner)
    }
}
#[doc = "\\brief Factory for constructing TopologyRefiners from specific mesh classes.\n\n TopologyRefinerFactory<MESH> is the factory class template to convert an instance of\n TopologyRefiner from an arbitrary mesh class.  While a class template, the implementation\n is not (cannot) be complete, so specialization of a few methods is required (it is a\n stateless factory, so no instance and only static methods).\n\n This template provides both the interface and high level assembly for the construction\n of the TopologyRefiner instance.  The high level construction executes a specific set\n of operations to convert the client's MESH into TopologyRefiner.  This set of operations\n combines methods independent of MESH from the base class with those specialized here for\n class MESH.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefinerFactory {
    pub _address: u8,
}
#[doc = " \\brief Options related to the construction of each TopologyRefiner.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyRefinerFactory_Options {
    #[doc = "< The subdivision scheme type identifier"]
    pub schemeType: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    #[doc = "< The full set of options for the scheme,\n< e.g. boundary interpolation rules..."]
    pub schemeOptions: OpenSubdiv_v3_6_1_Sdc_Options,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl OpenSubdiv_v3_6_1_Far_TopologyRefinerFactory_Options {
    #[inline]
    pub fn validateFullTopology(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_validateFullTopology(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        validateFullTopology: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let validateFullTopology: u32 = unsafe { ::std::mem::transmute(validateFullTopology) };
            validateFullTopology as u64
        });
        __bindgen_bitfield_unit
    }
}
pub use self::OpenSubdiv_v3_6_1_Vtr_internal_Level_TopologyError as OpenSubdiv_v3_6_1_Far_TopologyRefinerFactory_TopologyError;
#[doc = "\n \\brief  A simple reference to raw topology data for use with TopologyRefinerFactory\n\n TopologyDescriptor is a simple struct containing references to raw topology data used\n to construct a TopologyRefiner.  It is not a requirement but a convenience for use\n with TopologyRefinerFactory when mesh topology is not available in an existing mesh\n data structure.  It should be functionally complete and simple to use, but for more\n demanding situations, writing a custom Factory is usually warranted.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyDescriptor {
    pub numVertices: ::std::os::raw::c_int,
    pub numFaces: ::std::os::raw::c_int,
    pub numVertsPerFace: *const ::std::os::raw::c_int,
    pub vertIndicesPerFace: *const OpenSubdiv_v3_6_1_Far_Index,
    pub numCreases: ::std::os::raw::c_int,
    pub creaseVertexIndexPairs: *const OpenSubdiv_v3_6_1_Far_Index,
    pub creaseWeights: *const f32,
    pub numCorners: ::std::os::raw::c_int,
    pub cornerVertexIndices: *const OpenSubdiv_v3_6_1_Far_Index,
    pub cornerWeights: *const f32,
    pub numHoles: ::std::os::raw::c_int,
    pub holeIndices: *const OpenSubdiv_v3_6_1_Far_Index,
    pub isLeftHanded: bool,
    pub numFVarChannels: ::std::os::raw::c_int,
    pub fvarChannels: *const OpenSubdiv_v3_6_1_Far_TopologyDescriptor_FVarChannel,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_TopologyDescriptor_FVarChannel {
    pub numValues: ::std::os::raw::c_int,
    pub valueIndices: *const OpenSubdiv_v3_6_1_Far_Index,
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far18TopologyDescriptorC1Ev"]
    pub fn OpenSubdiv_v3_6_1_Far_TopologyDescriptor_TopologyDescriptor(
        this: *mut OpenSubdiv_v3_6_1_Far_TopologyDescriptor,
    );
}
impl OpenSubdiv_v3_6_1_Far_TopologyDescriptor {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Far_TopologyDescriptor_TopologyDescriptor(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " \\brief Describes the type of a patch\n\n Uniquely identifies all the different types of patches\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchDescriptor {
    pub _type: ::std::os::raw::c_uint,
}
#[doc = "< undefined"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_NON_PATCH:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 0;
#[doc = "< points (useful for cage drawing)"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_POINTS:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 1;
#[doc = "< lines  (useful for cage drawing)"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_LINES:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 2;
#[doc = "< 4-sided quadrilateral (bilinear)"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_QUADS:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 3;
#[doc = "< 3-sided triangle"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_TRIANGLES:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 4;
#[doc = "< regular triangular patch for the Loop scheme"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_LOOP:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 5;
#[doc = "< regular B-Spline patch for the Catmark scheme"]
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_REGULAR:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 6;
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_GREGORY:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 7;
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_GREGORY_BOUNDARY:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 8;
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_GREGORY_BASIS:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 9;
pub const OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type_GREGORY_TRIANGLE:
    OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = 10;
pub type OpenSubdiv_v3_6_1_Far_PatchDescriptor_Type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Returns a vector of all the legal patch descriptors for the\n        given adaptive subdivision scheme"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far15PatchDescriptor27GetAdaptivePatchDescriptorsENS0_3Sdc10SchemeTypeE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchDescriptor_GetAdaptivePatchDescriptors(
        type_: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Far_PatchDescriptor>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far15PatchDescriptor5printEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchDescriptor_print(
        this: *const OpenSubdiv_v3_6_1_Far_PatchDescriptor,
    );
}
impl OpenSubdiv_v3_6_1_Far_PatchDescriptor {
    #[inline]
    pub unsafe fn GetAdaptivePatchDescriptors(
        type_: OpenSubdiv_v3_6_1_Sdc_SchemeType,
    ) -> OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Far_PatchDescriptor> {
        OpenSubdiv_v3_6_1_Far_PatchDescriptor_GetAdaptivePatchDescriptors(type_)
    }
    #[inline]
    pub unsafe fn print(&self) {
        OpenSubdiv_v3_6_1_Far_PatchDescriptor_print(self)
    }
}
pub type OpenSubdiv_v3_6_1_Far_ConstPatchDescriptorArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Far_PatchDescriptor>;
#[doc = " \\brief Patch parameterization\n\n Topological refinement splits coarse mesh faces into refined faces.\n\n This patch parameterzation describes the relationship between one\n of these refined faces and its corresponding coarse face. It is used\n both for refined faces that are represented as full limit surface\n parametric patches as well as for refined faces represented as simple\n triangles or quads. This parameterization is needed to interpolate\n primvar data across a refined face.\n\n The U,V and refinement level parameters describe the scale and offset\n needed to map a location on the patch between levels of refinement.\n The encoding of these values exploits the quad-tree organization of\n the faces produced by subdivision. We encode the U,V origin of the\n patch using two 10-bit integer values and the refinement level as\n a 4-bit integer. This is sufficient to represent up through 10 levels\n of refinement.\n\n Special consideration must be given to the refined faces resulting from\n irregular coarse faces. We adopt a convention similar to Ptex texture\n mapping and define the parameterization for these faces in terms of the\n regular faces resulting from the first topological splitting of the\n irregular coarse face.\n\n When computing the basis functions needed to evaluate the limit surface\n parametric patch representing a refined face, we also need to know which\n edges of the patch are interpolated boundaries. These edges are encoded\n as a boundary bitmask identifying the boundary edges of the patch in\n sequential order starting from the first vertex of the refined face.\n\n A sparse topological refinement (like feature adaptive refinement) can\n produce refined faces that are adjacent to faces at the next level of\n subdivision. We identify these transitional edges with a transition\n bitmask using the same encoding as the boundary bitmask.\n\n For triangular subdivision schemes we specify the parameterization using\n a similar method. Alternate triangles at a given level of refinement\n are parameterized from their opposite corners and encoded as occupying\n the opposite diagonal of the quad-tree hierarchy. The third barycentric\n coordinate is dependent on and can be derived from the other two\n coordinates. This encoding also takes inspiration from the Ptex\n texture mapping specification.\n\n Bitfield layout :\n\n  Field0     | Bits | Content\n  -----------|:----:|------------------------------------------------------\n  faceId     | 28   | the faceId of the patch\n  transition | 4    | transition edge mask encoding\n\n  Field1     | Bits | Content\n  -----------|:----:|------------------------------------------------------\n  level      | 4    | the subdivision level of the patch\n  nonquad    | 1    | whether patch is refined from a non-quad face\n  regular    | 1    | whether patch is regular\n  unused     | 1    | unused\n  boundary   | 5    | boundary edge mask encoding\n  v          | 10   | log2 value of u parameter at first patch corner\n  u          | 10   | log2 value of v parameter at first patch corner\n\n Note : the bitfield is not expanded in the struct due to differences in how\n        GPU & CPU compilers pack bit-fields and endian-ness.\n\n*!\n\\verbatim\nQuad Patch Parameterization\n\n(0,1)                           (1,1)\n+-------+-------+---------------+\n|       |       |               |\n|   L2  |   L2  |               |\n|0,3    |1,3    |               |\n+-------+-------+       L1      |\n|       |       |               |\n|   L2  |   L2  |               |\n|0,2    |1,2    |1,1            |\n+-------+-------+---------------+\n|               |               |\n|               |               |\n|               |               |\n|       L1      |       L1      |\n|               |               |\n|               |               |\n|0,0            |1,0            |\n+---------------+---------------+\n(0,0)                           (1,0)\n\\endverbatim\n*/\n*!\n\\verbatim\nTriangle Patch Parameterization\n\n(0,1)                           (1,1)  (0,1,0)\n+-------+-------+---------------+       +\n| \\     | \\     | \\             |       | \\\n|L2 \\   |L2 \\   |   \\           |       |   \\\n|0,3  \\ |1,3  \\ |     \\         |       | L2  \\\n+-------+-------+       \\       |       +-------+\n| \\     | \\     |   L1    \\     |       | \\  L2 | \\\n|L2 \\   |L2 \\   |           \\   |       |   \\   |   \\\n|0,2  \\ |1,2  \\ |1,1          \\ |       | L2  \\ | L2  \\\n+-------+-------+---------------+       +-------+-------+\n| \\             | \\             |       | \\             | \\\n|   \\           |   \\           |       |   \\           |   \\\n|     \\         |     \\         |       |     \\    L1   |     \\\n|       \\       |       \\       |       |       \\       |       \\\n|   L1    \\     |   L1    \\     |       |   L1    \\     |   L1    \\\n|           \\   |           \\   |       |           \\   |           \\\n|0,0          \\ |1,0          \\ |       |             \\ |             \\\n+---------------+---------------+       +---------------+---------------+\n(0,0)                           (1,0)  (0,0,1)                         (1,0,0)\n\\endverbatim\n*/"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchParam {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl OpenSubdiv_v3_6_1_Far_PatchParam {
    #[inline]
    pub fn field0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_field0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn field1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_field1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        field0: ::std::os::raw::c_uint,
        field1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let field0: u32 = unsafe { ::std::mem::transmute(field0) };
            field0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let field1: u32 = unsafe { ::std::mem::transmute(field1) };
            field1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OpenSubdiv_v3_6_1_Far_PatchParamTable = [u64; 3usize];
pub type OpenSubdiv_v3_6_1_Far_PatchParamArray =
    OpenSubdiv_v3_6_1_Vtr_Array<OpenSubdiv_v3_6_1_Far_PatchParam>;
pub type OpenSubdiv_v3_6_1_Far_ConstPatchParamArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<OpenSubdiv_v3_6_1_Far_PatchParam>;
#[doc = " \\brief Container for arrays of parametric patches\n\n PatchTable contains topology and parametric information about the patches\n generated by the Refinement process. Patches in the table are sorted into\n arrays based on their PatchDescriptor Type.\n\n Note : PatchTable can be accessed either using a PatchHandle or a\n        combination of array and patch indices.\n\n XXXX manuelk we should add a PatchIterator that can dereference into\n              a PatchHandle for fast linear traversal of the table\n"]
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTable {
    pub _maxValence: ::std::os::raw::c_int,
    pub _numPtexFaces: ::std::os::raw::c_int,
    pub _patchArrays: OpenSubdiv_v3_6_1_Far_PatchTable_PatchArrayVector,
    pub _patchVerts: [u64; 3usize],
    pub _paramTable: OpenSubdiv_v3_6_1_Far_PatchParamTable,
    pub _quadOffsetsTable: OpenSubdiv_v3_6_1_Far_PatchTable_QuadOffsetsTable,
    pub _vertexValenceTable: OpenSubdiv_v3_6_1_Far_PatchTable_VertexValenceTable,
    pub _localPointStencils: OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr,
    pub _localPointVaryingStencils: OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr,
    pub _varyingDesc: OpenSubdiv_v3_6_1_Far_PatchDescriptor,
    pub _varyingVerts: [u64; 3usize],
    pub _fvarChannels: OpenSubdiv_v3_6_1_Far_PatchTable_FVarPatchChannelVector,
    pub _localPointFaceVaryingStencils: [u64; 3usize],
    pub _sharpnessIndices: [u64; 3usize],
    pub _sharpnessValues: [u64; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[doc = " \\brief Handle that can be used as unique patch identifier within PatchTable"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle {
    pub arrayIndex: OpenSubdiv_v3_6_1_Far_Index,
    pub patchIndex: OpenSubdiv_v3_6_1_Far_Index,
    pub vertIndex: OpenSubdiv_v3_6_1_Far_Index,
}
#[doc = " \\brief Accessors for the gregory patch evaluation buffers.\n        These methods will be deprecated.\n"]
pub type OpenSubdiv_v3_6_1_Far_PatchTable_ConstQuadOffsetsArray =
    OpenSubdiv_v3_6_1_Vtr_ConstArray<::std::os::raw::c_uint>;
pub type OpenSubdiv_v3_6_1_Far_PatchTable_VertexValenceTable = [u64; 3usize];
#[doc = "  @name Direct accessors\n\n \\warning These direct accessors are left for convenience, but they are\n          likely going to be deprecated in future releases\n"]
pub type OpenSubdiv_v3_6_1_Far_PatchTable_PatchVertsTable = [u64; 3usize];
pub type OpenSubdiv_v3_6_1_Far_PatchTable_QuadOffsetsTable = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTable_PatchArray {
    pub desc: OpenSubdiv_v3_6_1_Far_PatchDescriptor,
    pub numPatches: ::std::os::raw::c_int,
    pub vertIndex: OpenSubdiv_v3_6_1_Far_Index,
    pub patchIndex: OpenSubdiv_v3_6_1_Far_Index,
    pub quadOffsetIndex: OpenSubdiv_v3_6_1_Far_Index,
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable10PatchArray5printEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_PatchArray_print(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchArray,
    );
}
impl OpenSubdiv_v3_6_1_Far_PatchTable_PatchArray {
    #[inline]
    pub unsafe fn print(&self) {
        OpenSubdiv_v3_6_1_Far_PatchTable_PatchArray_print(self)
    }
}
pub type OpenSubdiv_v3_6_1_Far_PatchTable_PatchArrayVector = [u64; 3usize];
#[repr(C)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTable_FVarPatchChannel {
    pub interpolation: OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation,
    pub regDesc: OpenSubdiv_v3_6_1_Far_PatchDescriptor,
    pub irregDesc: OpenSubdiv_v3_6_1_Far_PatchDescriptor,
    pub stride: ::std::os::raw::c_int,
    pub patchValues: [u64; 3usize],
    pub patchParam: [u64; 3usize],
}
pub type OpenSubdiv_v3_6_1_Far_PatchTable_FVarPatchChannelVector = [u64; 3usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr {
    pub __bindgen_anon_1: OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr__bindgen_ty_1,
}
#[doc = " \\brief Table of subdivision stencils.\n\n Stencils are the most direct method of evaluation of locations on the limit\n of a surface. Every point of a limit surface can be computed by linearly\n blending a collection of coarse control vertices.\n\n A stencil assigns a series of control vertex indices with a blending weight\n that corresponds to a unique parametric location of the limit surface. When\n the control vertices move in space, the limit location can be very efficiently\n recomputed simply by applying the blending weights to the series of coarse\n control vertices.\n"]
pub type OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr_float_type =
    OpenSubdiv_v3_6_1_Far_StencilTableReal;
pub type OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr_double_type =
    OpenSubdiv_v3_6_1_Far_StencilTableReal;
#[repr(C)]
#[derive(Copy, Clone)]
pub union OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr__bindgen_ty_1 {
    pub _fPtr: *mut OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr_float_type,
    pub _dPtr: *mut OpenSubdiv_v3_6_1_Far_PatchTable_StencilTablePtr_double_type,
}
extern "C" {
    #[doc = " \\brief True if the patches are of feature adaptive types"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable17IsFeatureAdaptiveEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_IsFeatureAdaptive(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Returns the total number of patches stored in the table"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetNumPatchesTotalEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatchesTotal(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the PatchDescriptor for the patch identified by \\p handle"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetPatchDescriptorERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchDescriptor(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the control vertex indices for the patch identified by \\p handle"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable16GetPatchVerticesERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns a PatchParam for the patch identified by \\p handle"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable13GetPatchParamERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParam(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam;
}
extern "C" {
    #[doc = " \\brief Returns the control vertex indices for \\p patch in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable16GetPatchVerticesEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVertices1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the PatchParam for \\p patch in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable13GetPatchParamEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParam1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam;
}
extern "C" {
    #[doc = " \\brief Returns the number of patch arrays in the table"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable17GetNumPatchArraysEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatchArrays(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the number of patches in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable13GetNumPatchesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatches(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the number of control vertices in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable21GetNumControlVerticesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumControlVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the PatchDescriptor for the patches in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable23GetPatchArrayDescriptorEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayDescriptor(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the control vertex indices for the patches in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable21GetPatchArrayVerticesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the PatchParams for the patches in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable14GetPatchParamsEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParams(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray;
}
extern "C" {
    #[doc = " \\brief Returns the number of local vertex points."]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable17GetNumLocalPointsEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPoints(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the number of local varying points."]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable24GetNumLocalPointsVaryingEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPointsVarying(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the number of local face-varying points for \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable28GetNumLocalPointsFaceVaryingEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPointsFaceVarying(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the 'QuadOffsets' for the Gregory patch identified by \\p handle"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable19GetPatchQuadOffsetsERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchQuadOffsets(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchTable_ConstQuadOffsetsArray;
}
extern "C" {
    #[doc = " \\brief Returns the crease sharpness for the patch identified by \\p handle\n        if it is a single-crease patch, or 0.0f"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable34GetSingleCreasePatchSharpnessValueERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetSingleCreasePatchSharpnessValue(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Returns the crease sharpness for the \\p patch in \\p array\n        if it is a single-crease patch, or 0.0f"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable34GetSingleCreasePatchSharpnessValueEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetSingleCreasePatchSharpnessValue1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Returns the varying patch descriptor"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable25GetVaryingPatchDescriptorEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetVaryingPatchDescriptor(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the varying vertex indices for a given patch"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable23GetPatchVaryingVerticesERKNS2_11PatchHandleE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVaryingVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the varying vertex indices for a given patch"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable23GetPatchVaryingVerticesEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVaryingVertices1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the varying vertex indices for the patches in \\p array"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable28GetPatchArrayVaryingVerticesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayVaryingVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns an array of varying vertex indices for the patches."]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetVaryingVerticesEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetVaryingVertices(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the number of face-varying channels"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetNumFVarChannelsEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetNumFVarChannels(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the regular patch descriptor for \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable29GetFVarPatchDescriptorRegularEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptorRegular(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the irregular patch descriptor for \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable31GetFVarPatchDescriptorIrregularEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptorIrregular(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the default/irregular patch descriptor for \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable22GetFVarPatchDescriptorEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptor(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor;
}
extern "C" {
    #[doc = " \\brief Returns the value indices for a given patch in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetPatchFVarValuesERKNS2_11PatchHandleEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarValues(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the value indices for a given patch in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetPatchFVarValuesEiii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarValues1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the value indices for the patches in \\p array in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable23GetPatchArrayFVarValuesEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayFVarValues(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns an array of value indices for the patches in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable13GetFVarValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarValues(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray;
}
extern "C" {
    #[doc = " \\brief Returns the stride between patches in the value index array of \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetFVarValueStrideEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarValueStride(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the value indices for a given patch in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable22GetPatchFVarPatchParamERKNS2_11PatchHandleEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarPatchParam(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam;
}
extern "C" {
    #[doc = " \\brief Returns the face-varying params for a given patch \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable22GetPatchFVarPatchParamEiii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarPatchParam1(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam;
}
extern "C" {
    #[doc = " \\brief Returns the face-varying for a given patch in \\p array in \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable28GetPatchArrayFVarPatchParamsEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayFVarPatchParams(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray;
}
extern "C" {
    #[doc = " \\brief Returns an array of face-varying patch param for \\p channel"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable18GetFVarPatchParamsEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchParams(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray;
}
extern "C" {
    #[doc = " \\brief Deprecated @see PatchTable#GetFVarPatchDescriptor"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable33GetFVarChannelLinearInterpolationEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarChannelLinearInterpolation(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation;
}
extern "C" {
    #[doc = " debug helper"]
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable5printEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_print(this: *const OpenSubdiv_v3_6_1_Far_PatchTable);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10OpenSubdiv6v3_6_13Far10PatchTable13getPatchIndexEii"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_getPatchIndex(
        this: *const OpenSubdiv_v3_6_1_Far_PatchTable,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_Index;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTable14getPatchParamsEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_getPatchParams(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
        arrayIndex: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParamArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTable19getSharpnessIndicesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_getSharpnessIndices(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
        arrayIndex: OpenSubdiv_v3_6_1_Far_Index,
    ) -> *mut OpenSubdiv_v3_6_1_Far_Index;
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTable18getSharpnessValuesEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_getSharpnessValues(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
        arrayIndex: OpenSubdiv_v3_6_1_Far_Index,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " \\brief Copy constructor"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTableC1ERKS2_"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
        src: *const OpenSubdiv_v3_6_1_Far_PatchTable,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTableC1Ei"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable1(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
        maxvalence: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Destructor"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far10PatchTableD1Ev"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable_destructor(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTable,
    );
}
impl OpenSubdiv_v3_6_1_Far_PatchTable {
    #[inline]
    pub fn _isUniformLinear(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__isUniformLinear(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _vertexPrecisionIsDouble(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__vertexPrecisionIsDouble(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _varyingPrecisionIsDouble(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__varyingPrecisionIsDouble(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _faceVaryingPrecisionIsDouble(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__faceVaryingPrecisionIsDouble(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _isUniformLinear: ::std::os::raw::c_uint,
        _vertexPrecisionIsDouble: ::std::os::raw::c_uint,
        _varyingPrecisionIsDouble: ::std::os::raw::c_uint,
        _faceVaryingPrecisionIsDouble: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _isUniformLinear: u32 = unsafe { ::std::mem::transmute(_isUniformLinear) };
            _isUniformLinear as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _vertexPrecisionIsDouble: u32 =
                unsafe { ::std::mem::transmute(_vertexPrecisionIsDouble) };
            _vertexPrecisionIsDouble as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _varyingPrecisionIsDouble: u32 =
                unsafe { ::std::mem::transmute(_varyingPrecisionIsDouble) };
            _varyingPrecisionIsDouble as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _faceVaryingPrecisionIsDouble: u32 =
                unsafe { ::std::mem::transmute(_faceVaryingPrecisionIsDouble) };
            _faceVaryingPrecisionIsDouble as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn IsFeatureAdaptive(&self) -> bool {
        OpenSubdiv_v3_6_1_Far_PatchTable_IsFeatureAdaptive(self)
    }
    #[inline]
    pub unsafe fn GetNumPatchesTotal(&self) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatchesTotal(self)
    }
    #[inline]
    pub unsafe fn GetPatchDescriptor(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchDescriptor(self, handle)
    }
    #[inline]
    pub unsafe fn GetPatchVertices(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVertices(self, handle)
    }
    #[inline]
    pub unsafe fn GetPatchParam(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParam(self, handle)
    }
    #[inline]
    pub unsafe fn GetPatchVertices1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVertices1(self, array, patch)
    }
    #[inline]
    pub unsafe fn GetPatchParam1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParam1(self, array, patch)
    }
    #[inline]
    pub unsafe fn GetNumPatchArrays(&self) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatchArrays(self)
    }
    #[inline]
    pub unsafe fn GetNumPatches(&self, array: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumPatches(self, array)
    }
    #[inline]
    pub unsafe fn GetNumControlVertices(
        &self,
        array: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumControlVertices(self, array)
    }
    #[inline]
    pub unsafe fn GetPatchArrayDescriptor(
        &self,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayDescriptor(self, array)
    }
    #[inline]
    pub unsafe fn GetPatchArrayVertices(
        &self,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayVertices(self, array)
    }
    #[inline]
    pub unsafe fn GetPatchParams(
        &self,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchParams(self, array)
    }
    #[inline]
    pub unsafe fn GetNumLocalPoints(&self) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPoints(self)
    }
    #[inline]
    pub unsafe fn GetNumLocalPointsVarying(&self) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPointsVarying(self)
    }
    #[inline]
    pub unsafe fn GetNumLocalPointsFaceVarying(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumLocalPointsFaceVarying(self, channel)
    }
    #[inline]
    pub unsafe fn GetPatchQuadOffsets(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_PatchTable_ConstQuadOffsetsArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchQuadOffsets(self, handle)
    }
    #[inline]
    pub unsafe fn GetSingleCreasePatchSharpnessValue(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> f32 {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetSingleCreasePatchSharpnessValue(self, handle)
    }
    #[inline]
    pub unsafe fn GetSingleCreasePatchSharpnessValue1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> f32 {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetSingleCreasePatchSharpnessValue1(self, array, patch)
    }
    #[inline]
    pub unsafe fn GetVaryingPatchDescriptor(&self) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetVaryingPatchDescriptor(self)
    }
    #[inline]
    pub unsafe fn GetPatchVaryingVertices(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVaryingVertices(self, handle)
    }
    #[inline]
    pub unsafe fn GetPatchVaryingVertices1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchVaryingVertices1(self, array, patch)
    }
    #[inline]
    pub unsafe fn GetPatchArrayVaryingVertices(
        &self,
        array: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayVaryingVertices(self, array)
    }
    #[inline]
    pub unsafe fn GetVaryingVertices(&self) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetVaryingVertices(self)
    }
    #[inline]
    pub unsafe fn GetNumFVarChannels(&self) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetNumFVarChannels(self)
    }
    #[inline]
    pub unsafe fn GetFVarPatchDescriptorRegular(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptorRegular(self, channel)
    }
    #[inline]
    pub unsafe fn GetFVarPatchDescriptorIrregular(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptorIrregular(self, channel)
    }
    #[inline]
    pub unsafe fn GetFVarPatchDescriptor(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchDescriptor {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchDescriptor(self, channel)
    }
    #[inline]
    pub unsafe fn GetPatchFVarValues(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarValues(self, handle, channel)
    }
    #[inline]
    pub unsafe fn GetPatchFVarValues1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarValues1(self, array, patch, channel)
    }
    #[inline]
    pub unsafe fn GetPatchArrayFVarValues(
        &self,
        array: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayFVarValues(self, array, channel)
    }
    #[inline]
    pub unsafe fn GetFVarValues(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstIndexArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarValues(self, channel)
    }
    #[inline]
    pub unsafe fn GetFVarValueStride(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarValueStride(self, channel)
    }
    #[inline]
    pub unsafe fn GetPatchFVarPatchParam(
        &self,
        handle: *const OpenSubdiv_v3_6_1_Far_PatchTable_PatchHandle,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarPatchParam(self, handle, channel)
    }
    #[inline]
    pub unsafe fn GetPatchFVarPatchParam1(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParam {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchFVarPatchParam1(self, array, patch, channel)
    }
    #[inline]
    pub unsafe fn GetPatchArrayFVarPatchParams(
        &self,
        array: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetPatchArrayFVarPatchParams(self, array, channel)
    }
    #[inline]
    pub unsafe fn GetFVarPatchParams(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_ConstPatchParamArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarPatchParams(self, channel)
    }
    #[inline]
    pub unsafe fn GetFVarChannelLinearInterpolation(
        &self,
        channel: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Sdc_Options_FVarLinearInterpolation {
        OpenSubdiv_v3_6_1_Far_PatchTable_GetFVarChannelLinearInterpolation(self, channel)
    }
    #[inline]
    pub unsafe fn print(&self) {
        OpenSubdiv_v3_6_1_Far_PatchTable_print(self)
    }
    #[inline]
    pub unsafe fn getPatchIndex(
        &self,
        array: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_Index {
        OpenSubdiv_v3_6_1_Far_PatchTable_getPatchIndex(self, array, patch)
    }
    #[inline]
    pub unsafe fn getPatchParams(
        &mut self,
        arrayIndex: ::std::os::raw::c_int,
    ) -> OpenSubdiv_v3_6_1_Far_PatchParamArray {
        OpenSubdiv_v3_6_1_Far_PatchTable_getPatchParams(self, arrayIndex)
    }
    #[inline]
    pub unsafe fn getSharpnessIndices(
        &mut self,
        arrayIndex: OpenSubdiv_v3_6_1_Far_Index,
    ) -> *mut OpenSubdiv_v3_6_1_Far_Index {
        OpenSubdiv_v3_6_1_Far_PatchTable_getSharpnessIndices(self, arrayIndex)
    }
    #[inline]
    pub unsafe fn getSharpnessValues(
        &mut self,
        arrayIndex: OpenSubdiv_v3_6_1_Far_Index,
    ) -> *mut f32 {
        OpenSubdiv_v3_6_1_Far_PatchTable_getSharpnessValues(self, arrayIndex)
    }
    #[inline]
    pub unsafe fn new(src: *const OpenSubdiv_v3_6_1_Far_PatchTable) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(maxvalence: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable1(__bindgen_tmp.as_mut_ptr(), maxvalence);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        OpenSubdiv_v3_6_1_Far_PatchTable_PatchTable_destructor(self)
    }
}
#[doc = " \\brief Factory for constructing a PatchTable from a TopologyRefiner\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTableFactory {
    pub _address: u8,
}
#[doc = " \\brief Public options for the PatchTable factory\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "< Number of channel indices and interpolation modes passed"]
    pub numFVarChannels: ::std::os::raw::c_int,
    #[doc = "< List containing the indices of the channels selected for the factory"]
    pub fvarChannelIndices: *const ::std::os::raw::c_int,
}
#[doc = "< unspecified"]
pub const OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType_ENDCAP_NONE:
    OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = 0;
#[doc = "< use linear patches (simple quads or tris)"]
pub const OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType_ENDCAP_BILINEAR_BASIS:
    OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = 1;
#[doc = "< use BSpline-like patches (same patch type as regular)"]
pub const OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType_ENDCAP_BSPLINE_BASIS:
    OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = 2;
#[doc = "< use Gregory patches (highest quality, recommended default)"]
pub const OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType_ENDCAP_GREGORY_BASIS:
    OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = 3;
#[doc = "< legacy option for 2.x style Gregory patches (Catmark only)"]
pub const OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType_ENDCAP_LEGACY_GREGORY:
    OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = 4;
#[doc = " \\brief Choice for approximating irregular patches (end-caps)\n\n This enum specifies how irregular patches (end-caps) are approximated.\n A basis is chosen, rather than a specific patch type, and has a\n corresponding patch type for each subdivision scheme, i.e. a quad and\n triangular patch type exists for each basis.  These choices provide a\n trade-off between surface quality and performance.\n"]
pub type OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options_EndCapType = ::std::os::raw::c_uint;
impl OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options {
    #[inline]
    pub fn generateAllLevels(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateAllLevels(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn includeBaseLevelIndices(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_includeBaseLevelIndices(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn includeFVarBaseLevelIndices(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_includeFVarBaseLevelIndices(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn triangulateQuads(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_triangulateQuads(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useSingleCreasePatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useSingleCreasePatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useInfSharpPatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useInfSharpPatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn maxIsolationLevel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_maxIsolationLevel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn endCapType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_endCapType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn shareEndCapPatchPoints(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shareEndCapPatchPoints(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generateVaryingTables(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateVaryingTables(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generateVaryingLocalPoints(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateVaryingLocalPoints(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generateFVarTables(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateFVarTables(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn patchPrecisionDouble(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_patchPrecisionDouble(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fvarPatchPrecisionDouble(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fvarPatchPrecisionDouble(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generateFVarLegacyLinearPatches(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateFVarLegacyLinearPatches(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generateLegacySharpCornerPatches(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_generateLegacySharpCornerPatches(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        generateAllLevels: ::std::os::raw::c_uint,
        includeBaseLevelIndices: ::std::os::raw::c_uint,
        includeFVarBaseLevelIndices: ::std::os::raw::c_uint,
        triangulateQuads: ::std::os::raw::c_uint,
        useSingleCreasePatch: ::std::os::raw::c_uint,
        useInfSharpPatch: ::std::os::raw::c_uint,
        maxIsolationLevel: ::std::os::raw::c_uint,
        endCapType: ::std::os::raw::c_uint,
        shareEndCapPatchPoints: ::std::os::raw::c_uint,
        generateVaryingTables: ::std::os::raw::c_uint,
        generateVaryingLocalPoints: ::std::os::raw::c_uint,
        generateFVarTables: ::std::os::raw::c_uint,
        patchPrecisionDouble: ::std::os::raw::c_uint,
        fvarPatchPrecisionDouble: ::std::os::raw::c_uint,
        generateFVarLegacyLinearPatches: ::std::os::raw::c_uint,
        generateLegacySharpCornerPatches: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let generateAllLevels: u32 = unsafe { ::std::mem::transmute(generateAllLevels) };
            generateAllLevels as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let includeBaseLevelIndices: u32 =
                unsafe { ::std::mem::transmute(includeBaseLevelIndices) };
            includeBaseLevelIndices as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let includeFVarBaseLevelIndices: u32 =
                unsafe { ::std::mem::transmute(includeFVarBaseLevelIndices) };
            includeFVarBaseLevelIndices as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let triangulateQuads: u32 = unsafe { ::std::mem::transmute(triangulateQuads) };
            triangulateQuads as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let useSingleCreasePatch: u32 = unsafe { ::std::mem::transmute(useSingleCreasePatch) };
            useSingleCreasePatch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let useInfSharpPatch: u32 = unsafe { ::std::mem::transmute(useInfSharpPatch) };
            useInfSharpPatch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let maxIsolationLevel: u32 = unsafe { ::std::mem::transmute(maxIsolationLevel) };
            maxIsolationLevel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let endCapType: u32 = unsafe { ::std::mem::transmute(endCapType) };
            endCapType as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let shareEndCapPatchPoints: u32 =
                unsafe { ::std::mem::transmute(shareEndCapPatchPoints) };
            shareEndCapPatchPoints as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let generateVaryingTables: u32 =
                unsafe { ::std::mem::transmute(generateVaryingTables) };
            generateVaryingTables as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let generateVaryingLocalPoints: u32 =
                unsafe { ::std::mem::transmute(generateVaryingLocalPoints) };
            generateVaryingLocalPoints as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let generateFVarTables: u32 = unsafe { ::std::mem::transmute(generateFVarTables) };
            generateFVarTables as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let patchPrecisionDouble: u32 = unsafe { ::std::mem::transmute(patchPrecisionDouble) };
            patchPrecisionDouble as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let fvarPatchPrecisionDouble: u32 =
                unsafe { ::std::mem::transmute(fvarPatchPrecisionDouble) };
            fvarPatchPrecisionDouble as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let generateFVarLegacyLinearPatches: u32 =
                unsafe { ::std::mem::transmute(generateFVarLegacyLinearPatches) };
            generateFVarLegacyLinearPatches as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let generateLegacySharpCornerPatches: u32 =
                unsafe { ::std::mem::transmute(generateLegacySharpCornerPatches) };
            generateLegacySharpCornerPatches as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\brief Obsolete internal struct not intended for public use -- due to\n be deprecated."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far17PatchTableFactory12PatchFaceTag5clearEv"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_clear(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far17PatchTableFactory12PatchFaceTag36assignBoundaryPropertiesFromEdgeMaskEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignBoundaryPropertiesFromEdgeMask(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag,
        boundaryEdgeMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far17PatchTableFactory12PatchFaceTag38assignBoundaryPropertiesFromVertexMaskEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignBoundaryPropertiesFromVertexMask(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag,
        boundaryVertexMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far17PatchTableFactory12PatchFaceTag38assignTransitionPropertiesFromEdgeMaskEi"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignTransitionPropertiesFromEdgeMask(
        this: *mut OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag,
        boundaryVertexMask: ::std::os::raw::c_int,
    );
}
impl OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag {
    #[inline]
    pub fn _hasPatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__hasPatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _isRegular(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__isRegular(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _transitionMask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__transitionMask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _boundaryMask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__boundaryMask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _boundaryIndex(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set__boundaryIndex(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn _boundaryCount(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set__boundaryCount(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn _hasBoundaryEdge(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set__hasBoundaryEdge(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn _isSingleCrease(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__isSingleCrease(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _hasPatch: ::std::os::raw::c_uint,
        _isRegular: ::std::os::raw::c_uint,
        _transitionMask: ::std::os::raw::c_uint,
        _boundaryMask: ::std::os::raw::c_uint,
        _boundaryIndex: ::std::os::raw::c_uint,
        _boundaryCount: ::std::os::raw::c_uint,
        _hasBoundaryEdge: ::std::os::raw::c_uint,
        _isSingleCrease: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _hasPatch: u32 = unsafe { ::std::mem::transmute(_hasPatch) };
            _hasPatch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _isRegular: u32 = unsafe { ::std::mem::transmute(_isRegular) };
            _isRegular as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let _transitionMask: u32 = unsafe { ::std::mem::transmute(_transitionMask) };
            _transitionMask as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let _boundaryMask: u32 = unsafe { ::std::mem::transmute(_boundaryMask) };
            _boundaryMask as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let _boundaryIndex: u32 = unsafe { ::std::mem::transmute(_boundaryIndex) };
            _boundaryIndex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let _boundaryCount: u32 = unsafe { ::std::mem::transmute(_boundaryCount) };
            _boundaryCount as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let _hasBoundaryEdge: u32 = unsafe { ::std::mem::transmute(_hasBoundaryEdge) };
            _hasBoundaryEdge as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let _isSingleCrease: u32 = unsafe { ::std::mem::transmute(_isSingleCrease) };
            _isSingleCrease as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_clear(self)
    }
    #[inline]
    pub unsafe fn assignBoundaryPropertiesFromEdgeMask(
        &mut self,
        boundaryEdgeMask: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignBoundaryPropertiesFromEdgeMask(
            self,
            boundaryEdgeMask,
        )
    }
    #[inline]
    pub unsafe fn assignBoundaryPropertiesFromVertexMask(
        &mut self,
        boundaryVertexMask: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignBoundaryPropertiesFromVertexMask(
            self,
            boundaryVertexMask,
        )
    }
    #[inline]
    pub unsafe fn assignTransitionPropertiesFromEdgeMask(
        &mut self,
        boundaryVertexMask: ::std::os::raw::c_int,
    ) {
        OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchFaceTag_assignTransitionPropertiesFromEdgeMask(
            self,
            boundaryVertexMask,
        )
    }
}
pub type OpenSubdiv_v3_6_1_Far_PatchTableFactory_PatchTagVector = u8;
extern "C" {
    #[doc = " \\brief Instantiates a PatchTable from a client-provided TopologyRefiner.\n\n  A PatchTable can be constructed from a TopologyRefiner that has been\n  either adaptively or uniformly refined.  In both cases, the resulting\n  patches reference vertices in the various refined levels by index,\n  and those indices accumulate with the levels in different ways.\n\n  For adaptively refined patches, patches are defined at different levels,\n  including the base level, so the indices of patch vertices include\n  vertices from all levels.  A sparse set of patches can be created by\n  restricting the patches generated to those descending from a given set\n  of faces at the base level.  This sparse set of base faces is expected\n  to be a subset of the faces that were adaptively refined in the given\n  TopologyRefiner, otherwise results are undefined.\n\n  For uniformly refined patches, all patches are completely defined within\n  the last level.  There is often no use for intermediate levels and they\n  can usually be ignored.  Indices of patch vertices might therefore be\n  expected to be defined solely within the last level.  While this is true\n  for face-varying patches, for historical reasons it is not the case for\n  vertex and varying patches.  Indices for vertex and varying patches include\n  the base level in addition to the last level while indices for face-varying\n  patches include only the last level.\n\n @param refiner        TopologyRefiner from which to generate patches\n\n @param options        Options controlling the creation of the table\n\n @param selectedFaces  Only create patches for the given set of base faces.\n\n @return               A new instance of PatchTable\n"]
    #[link_name = "\u{1}_ZN10OpenSubdiv6v3_6_13Far17PatchTableFactory6CreateERKNS1_15TopologyRefinerENS2_7OptionsENS0_3Vtr10ConstArrayIiEE"]
    pub fn OpenSubdiv_v3_6_1_Far_PatchTableFactory_Create(
        refiner: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        options: OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options,
        selectedFaces: OpenSubdiv_v3_6_1_Far_ConstIndexArray,
    ) -> *mut OpenSubdiv_v3_6_1_Far_PatchTable;
}
impl OpenSubdiv_v3_6_1_Far_PatchTableFactory {
    #[inline]
    pub unsafe fn Create(
        refiner: *const OpenSubdiv_v3_6_1_Far_TopologyRefiner,
        options: OpenSubdiv_v3_6_1_Far_PatchTableFactory_Options,
        selectedFaces: OpenSubdiv_v3_6_1_Far_ConstIndexArray,
    ) -> *mut OpenSubdiv_v3_6_1_Far_PatchTable {
        OpenSubdiv_v3_6_1_Far_PatchTableFactory_Create(refiner, options, selectedFaces)
    }
}
